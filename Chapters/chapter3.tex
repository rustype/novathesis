%!TEX root = ../template.tex
\chapter{Designing a DSL in Rust (10/02/2021)}\label{cha:rust-dsl}

\section{Rust Macros}

Just like its predecessors, C \& C++, Rust offers macros as part of the language.
In essence, Rust macros are just like other languages macro's, they generate code before compilation.
However, Rust provides two kinds of macros, \emph{macros by example} (also known as \texttt{macro\_rules!}),
and procedural macros (also known as \texttt{proc-macros}).

\subsection{Macros by example}

The name \emph{macros by example} comes from the way they are written, by pattern matching,
the user writes a pattern that matches a bit on input and the macro will replace it with the defined output.
The most notable differences between C and Rust macros are their hygiene and “\emph{type}”,
C macros are unhygienic and do not distinguish inputs, whereas Rust macros are hygienic
and distinguish between thirteen input kinds (e.g. \texttt{ident}, \texttt{stmt}, \texttt{literal}, etc).

% TODO insert an example
% TODO add more text
% TODO add references to the reference

\subsection{Proc-macros}

Rust also has another macro mechanism, \emph{procedural macros},
these can take three forms: \emph{function-like macros}, \emph{derive macros} and \emph{attribute macros}.
In a nutshell, procedural macros allow users to run code at compile time, consuming and producing Rust syntax.

In contrast with \texttt{macro\_rules!}, procedural macros are \emph{unhygienic},
meaning their output can interfere with the surrounding code and vice-versa,
like C macros, they act as if the output code was simply written in the original source file.
This leads developers to be required to add a series of extra measures when outputting code
such as using absolute paths and function names which are unlikely of clashing with user code.

% TODO add Koriaxet guide here

% TODO add subsubsections/paragraphs on all three kinds of macros

\section{The DSL}
\subsection{Objectives}
What the DSL should achieve
\subsection{Architecture}
How it achieves it