%!TEX root = ../template.tex
\chapter{Introduction (20/01/2021)}\label{cha:introduction}

\section{Context}\label{sec:context}

% [11/01/2021]
% TODO - Review if links should go in the bibliography
% TODO - Review last paragraph and overall all "cohesiveness" of the text

Users face bugs on a daily basis, whether in their instant messaging application or a game,
bugs currently permeate our lives, they are mostly harmless as such applications are not critical,
resulting in some unsent messages or texture glitches.

However, in areas as systems programming, one of the most demanding domains in computer science,
bugs and their respective consequences come at a high cost to both service providers and consumers.
There are reports from several industries where bugs lead to huge monetary losses and even death.

In 2014, the Heartbleed~\autocite{Heartbleed} bug, caused due to a missing bound check,
compromised the security of any OpenSSL user, enabling the theft of critical information (e.g. cryptographic keys).
In 2018, a bug in Coinbase (a popular cryptocurrency exchange)
allowed for account balance manipulation~\autocite{Vicompany2018}.
In 2019 and 2020, after several crashes~\autocite{Campbell2019},
the Boeing 737 Max was grounded to fix existing problems, while grounded,
more software-related issues were
found~\autocite{Okane2019,Okane2020},
delaying its re-certification.
In 2020, as the number of COVID-19 grew,
contact tracing apps were deployed as a mitigation strategy.
The UK's National Health Service app failed to ask users to self-isolate due to a
bug~\autocite{Mageit2020}.

The previous examples are not isolated incidents, the language and nature of the bugs is different for each case,
to put it simply, there is no silver bullet and the next best alternative is to do our best to mitigate them by
building tools and abstractions which allow developers to increase their code's safety.

Languages like C/C++ have dominated the systems programming landscape for years and
one of the main problems with both is the lack of memory management.
Leaving such responsibility to the developer has proven to be \emph{a less than ideal}
solution, with $70\%$ of bugs in projects like Chromium~\autocite{chromium}
and Microsoft products~\autocite{Miller2019} being due to memory management.

To address such problem, several tools and languages have been and continue to be developed,
so far, Rust has been the only one to achieve \emph{mainstream} status.
% Rust aims to provide memory safety without affecting performance or productivity,
% to achieve such ambitious goal, Rust validates code with the borrow checker, which then enforces memory safety rules,
% targeting the problem at its root.

\section{The Rust Language}\label{sec:rust-lang}

Rust is a fairly recent systems programming language,
its main focus revolves around memory safety,
effectively removing classes of such bugs (e.g. \emph{use-after-free} and \emph{double-free}).
Another one of Rust's focus, is on productivity,
aiming to provide the safety mechanisms necessary to remove the previous class of bugs,
while trying to provide a pleasant and productive development experience.

To achieve its goals, Rust makes use of a borrow checker and an ownership system,
in conjunction, they're responsible for guaranteeing correct memory usage.
At its core, the borrow checker is a lightweight theorem prover,
it tries to prove that the code does not break safety rules.

Its rules can be distilled down to the following intuition,
only one entity can hold a reference to mutable data at a time,
several entities may hold references to immutable data.
This also enables Rust to also provide mechanisms which help deal with concurrency,
allowing for developers to write data-race free
code~\autocite{Turon2015}.

\section{Typestates}\label{sec:typestates}

Typestates were introduced in~\autocite{Strom1983},
they are a subset of behavioral types and
according to the same article, typestates are a
\emph{mechanism in which the compiler guarantees that for all execution paths,
the sequence of operations on each variable obeys a finite state grammar associated with that variable's type}.

The first language to make use of typestates was NIL~\autocite{Strom1983},
afterwards languages like Hermes~\autocite{Strom1990} and Plaid~\autocite{Aldrich2009}
extended the concept with new techniques.

\subsection{The case for typestates}

As discussed in \autoref{sec:context}, bugs in systems programming are costly,
thus, bugs must be minimized.
Several tools, such as static analyzers, fuzzers, testing frameworks and others,
aid in this purpose, if we have all these external tools,
why should we not try and leverage the programming language itself?

\paragraph{Moving towards better languages}
Programming languages allow the programmer to express a set of actions to be taken by the computer,
they are tools which enable us to achieve a goal.
Being essential to our work, better tools enable developers to be more productive and achieve higher quality work.
The remaining question is “\emph{why do we not create better languages?}”.
Even when considering languages to be cheap to develop,
the amount of work between a \emph{working} language to be \emph{production ready} is not cheap.
Furthermore, while adopting a new language for a hobby project is easy,
the same does not apply for enterprise level projects,
requiring several developers to know the ins and outs of the language.

\paragraph{Static typed languages}
The current trend is to move from dynamically typed languages,
to statically typed ones, or at the very least, add typing support to existing dynamic languages.
Typescript~\autocite{typescript},
Reason~\autocite{reason} and
PureScript~\autocite{purescript}
are all examples of languages built to bridge the gap between static type systems and JavaScript.
Python and Ruby, two popular dynamic languages, have also pushed for type adoption
with the addition of type hint support in recent
releases~\autocite{PythonTyping, RubyRBS}.

\paragraph{Where do typestates fit?}
Typestates are a complex subject, able to be adopted at several levels,
just like type hints, they can be partially used in some languages,
through tools such as Mungo~\autocite{Voinea2020},
by contract-style assertions as in Ada2012, Eiffel or pre-0.4 Rust,
or finally by leveraging the existing type system to write typestate enabled code as it is possible in
Rust~\autocite{Duarte2020}.

\paragraph{Why use typestates?}
By leveraging the state to the typesystem, the compiler is able to aid the programmer during development,
a given set of transitions will be impossible by default, since the types do not implement them. % TODO maybe add an example
By reducing the need for developers to check for a certain set of conditions through the use of typestates,
it becomes possible to reduce the number of runtime assertions and
completely eliminate the need for illegal state exceptions since illegal transitions are checked at compile time.


\subsection{Typestates in action}

\subsubsection*{Plaid}

Plaid is a typestate-oriented programming language \autocite{Aldrich2009},
instead of \keyword{class}es users write \keyword{typestate}s.
Each typestate represents a class in its possible states,
its methods and behavior change during runtime as state changes,
in contrast with other languages (e.g. Java) where public methods and fields are always available.

This property allows the typesystem to enforce certain properties at compile time,
such as certain methods will never be called in a given state since it is not possible by design
(i.e. they are not available in the interface).


\subsubsection*{Rust}

As discussed in \autoref{sec:rust-lang}, Rust takes its commitment with safety with seriousness,
providing the necessary tools to users.
While Rust does not support first-class typestates,
it is possible to emulate them using its type system (as demonstrated in \autocite{Duarte2020}),
this is discussed in further sections of this document.

\paragraph{Embedded Rust.} As any systems programming language, Rust penetrated the embedded development space.
Its features are most adequate and the community has put great effort into making Rust a viable language for embedded systems.

\emph{The Embedded Rust Book}'s~\autocite{Rust2021} Chapter 4 is dedicated to static guarantees,
introducing programmers to the concepts of typestate in Section 4.1, and their usage in embedded systems.

As for real-world usage, typestates are abundantly used in the area (not just discussed in the book),
under \autocite{Stm32} one finds several repositories (suffixed with \texttt{-hal})
which implement typestates
(e.g. \href{https://github.com/stm32-rs/stm32h7xx-hal/blob/master/src/gpio.rs#L51-L128}{\texttt{gpio.rs}}
from \texttt{stm32h7xx-hal}).

\subsubsection*{Obsidian}

Obsidian is a language targeting Hyperledger Fabric \autocite{Fabric2021},
among other features it makes use of typestates to reduce the amount of bugs when dealing with assets.

In \autocite{Coblenz2020} an empirical study tested and proved Obsidian claims,
when compared with Solidity, the leading blockchain language,
users inserted fewer bugs and were able to start developing safer code faster.

% We now present a shallow review over their usefulness,
% possible approaches to typestates and challenges faced when adding typestates to a language.

% % \subsection{What are Typestates?}\label{sec:typestates:what-are-typestates}

% \subsection{Why are Typestates useful?}\label{sec:typestates:why-are-typestates-useful}

% Typestates allow the developer to provide more expressive APIs, as well as securer ones.
% Currently, in \emph{typestateless} programming,
% programmers are required to track object state in their heads, with the help of comments,
% the code itself and possibly the debugger, running the code and checking their assumptions by hand.

% As a simple example, consider the Java application in \autoref{fig:java-mult} which simply takes two numbers and multiples them together.
% The application will throw an exception on line 6,
% since the programmer closed the \texttt{Scanner} in line 5.
% In this example, the error is simple to catch,
% the program is short and the \texttt{Scanner} can either be open or closed,
% however, real-world applications are not that simple.

% \begin{figure}
%     \centering
%     \begin{minted}{java}
% public class Mult {
%     public static void main(String[] args) {
%         Scanner s = new Scanner(System.in);
%         int lhs = Integer.parseInt(s.nextLine());
%         s.close();
%         int rhs = Integer.parseInt(s.nextLine());
%         System.out.println(lhs * rhs);
%     }
% }
%     \end{minted}
%     \label{fig:java-mult}
%     \caption{The \texttt{Mult} program, which reads two integer and multiplies them together.}
% \end{figure}

% In the case of \emph{typestated} programming,
% the type system will provide the programmer with better tools to express state,
% furthermore, the compiler will then catch errors regarding state,
% such as the previous \emph{use-after-close}.

% \autoref{fig:java-mult-typestate} shows the \texttt{Mult} program written in a typestated fashion,
% notice that the \texttt{Scanner} type is now augmented with its state.
% % This extra information allows the compiler to

% \begin{figure}
%     \centering
%     \begin{minted}{java}
% public class Mult {
%     public static void main(String[] args) {
%         Scanner[Open] s = new Scanner(System.in);
%         int lhs = Integer.parseInt(s.nextLine());
%         Scanner[Closed] s = s.close();
%         int rhs = Integer.parseInt(s.nextLine());
%         System.out.println(lhs * rhs);
%     }
% }
%     \end{minted}
%     \label{fig:java-mult-typestate}
%     \caption{The \texttt{Mult} program, written in a typestated fashion.}
% \end{figure}

% \subsection{Approaches}

% As previously discussed, simply put, typestates are the elevation of state to the type system.
% Currently, there are three main approaches to typestates,
% some can be retrofitted into existing languages.

% \paragraph{State-Based Design}
% This is the most common approach, able to be used in any language,
% essentially, all responsibility is on the developer, which is required to track state at runtime by adding
% state checking barriers (e.g. \texttt{if CurrentState == DesiredState}).
% In such case, state modelling will be done using enumerations or the language equivalent.

% \paragraph{Typestate Checkers}
% Typestate checkers are external tools to the language,
% they may take the form of an independent tool or a compiler plugin.
% Their goal is to run as part of the compilation stage and enforce the desired state transitions in the code.
% The biggest problem with tools like these,
% is the added complexity of extra tools over the build process.

% \paragraph{Language-Based}
% The language-based approach is the most solid approach to the problem.
% At a conceptual level it is also the simplest approach,
% instead of adding features to existing languages just to enable typestate support,
% it prioritizes typestates and makes them a first-class language construct.
% This approach is the one taken by languages such as \todo{Add ref}[Plaid].


% \subsection{Challenges}

% Typestates are not without their challenges,
% attentive readers might notice that if objects are mutably aliased,
% typestate guarantees cannot hold since the object can be mutated,
% changing state while a client depends on the previous one.

% \missingfigure{Picture which exemplifies the mutable alias problem.}

% Solving this problem requires objects to be owned by a single client,
% this is due to the fact that even if an immutable alias exists,
% its type may be mutated by the original owner.

% \todo{Verify this with the advisor}Such solution requires the type system to be at least affine,
% being able to enforce a \emph{use at most once} policy over the language objects.

% % \section{State Machines}\label{sec:state-machines}

% % \section{What is the relation between them?}\label{sec:ts-fsm-relation}

% \section{The Rust Language}\label{sec:rust}

% \subsection{Why Rust?}\label{sec:rust:why}