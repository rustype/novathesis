%!TEX root = ../template.tex
\chapter{Introduction}\label{cha:introduction}

\section{Typestates}\label{sec:typestates}

Typestates are a subset of behavioral types, the core concept behind them is the elevation of state to the type system.
\todo{Add references to NLL, Hermes and Plaid} They were first introduced by [NLL/Hermes],
recently typestates have been further studied by [Aldrich].

We now present a shallow review over their usefulness,
possible approaches to typestates and challenges faced when adding typestates to a language.

% \subsection{What are Typestates?}\label{sec:typestates:what-are-typestates}

\subsection{Why are Typestates useful?}\label{sec:typestates:why-are-typestates-useful}

Typestates allow the developer to provide more expressive APIs, as well as securer ones.
Currently, in \emph{typestateless} programming,
programmers are required to track object state in their heads, with the help of comments,
the code itself and possibly the debugger, running the code and checking their assumptions by hand.

As a simple example, consider the Java application in \autoref{fig:java-mult} which simply takes two numbers and multiples them together.
The application will throw an exception on line 6,
since the programmer closed the \texttt{Scanner} in line 5.
In this example, the error is simple to catch,
the program is short and the \texttt{Scanner} can either be open or closed,
however, real-world applications are not that simple.

\begin{figure}
    \centering
    \begin{minted}{java}
public class Mult {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int lhs = Integer.parseInt(s.nextLine());
        s.close();
        int rhs = Integer.parseInt(s.nextLine());
        System.out.println(lhs * rhs);
    }
}
    \end{minted}
    \label{fig:java-mult}
    \caption{The \texttt{Mult} program, which reads two integer and multiplies them together.}
\end{figure}

In the case of \emph{typestated} programming,
the type system will provide the programmer with better tools to express state,
furthermore, the compiler will then catch errors regarding state,
such as the previous \emph{use-after-close}.

\autoref{fig:java-mult-typestate} shows the \texttt{Mult} program written in a typestated fashion,
notice that the \texttt{Scanner} type is now augmented with its state.
% This extra information allows the compiler to

\begin{figure}
    \centering
    \begin{minted}{java}
public class Mult {
    public static void main(String[] args) {
        Scanner[Open] s = new Scanner(System.in);
        int lhs = Integer.parseInt(s.nextLine());
        Scanner[Closed] s = s.close();
        int rhs = Integer.parseInt(s.nextLine());
        System.out.println(lhs * rhs);
    }
}
    \end{minted}
    \label{fig:java-mult-typestate}
    \caption{The \texttt{Mult} program, written in a typestated fashion.}
\end{figure}

\subsection{Approaches}

As previously discussed, simply put, typestates are the elevation of state to the type system.
Currently, there are three main approaches to typestates,
some can be retrofitted into existing languages.

\paragraph{State-Based Design}
This is the most common approach, able to be used in any language,
essentially, all responsibility is on the developer, which is required to track state at runtime by adding
state checking barriers (e.g. \texttt{if CurrentState == DesiredState}).
In such case, state modelling will be done using enumerations or the language equivalent.

\paragraph{Typestate Checkers}
Typestate checkers are external tools to the language,
they may take the form of an independent tool or a compiler plugin.
Their goal is to run as part of the compilation stage and enforce the desired state transitions in the code.
The biggest problem with tools like these,
is the added complexity of extra tools over the build process.

\paragraph{Language-Based}
The language-based approach is the most solid approach to the problem.
At a conceptual level it is also the simplest approach,
instead of adding features to existing languages just to enable typestate support,
it prioritizes typestates and makes them a first-class language construct.
This approach is the one taken by languages such as \todo{Add ref}[Plaid].


\subsection{Challenges}

Typestates are not without their challenges,
attentive readers might notice that if objects are mutably aliased,
typestate guarantees cannot hold since the object can be mutated,
changing state while a client depends on the previous one.

\missingfigure{Picture which exemplifies the mutable alias problem.}

Solving this problem requires objects to be owned by a single client,
this is due to the fact that even if an immutable alias exists,
its type may be mutated by the original owner.

\todo{Verify this with the advisor}Such solution requires the type system to be at least affine,
being able to enforce a \emph{use at most once} policy over the language objects.

% \section{State Machines}\label{sec:state-machines}

% \section{What is the relation between them?}\label{sec:ts-fsm-relation}

\section{The Rust Language}\label{sec:rust}

\subsection{Why Rust?}\label{sec:rust:why}