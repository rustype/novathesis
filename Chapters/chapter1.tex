%!TEX root = ../template.tex
\chapter{Introduction (20/01/2021)}\label{cha:introduction}

\section{Context}\label{sec:context}

% [11/01/2021]
% TODO - Review if links should go in the bibliography
% TODO - Review last paragraph and overall all "cohesiveness" of the text

Users face bugs on a daily basis, whether in their instant messaging application or a game,
bugs currently permeate our lives, they are mostly harmless as such applications are not critical,
resulting in some unsent messages or texture glitches.

However, in areas as systems programming, one of the most demanding domains in computer science,
bugs and their respective consequences come at a high cost to both service providers and consumers.
There are reports from several industries where bugs lead to huge monetary losses and even death.

In 2014, the Heartbleed~\autocite{Heartbleed} bug, caused due to a missing bound check,
compromised the security of any OpenSSL user, enabling the theft of critical information (e.g. cryptographic keys).
In 2018, a bug in Coinbase (a popular cryptocurrency exchange)
allowed for account balance manipulation~\autocite{Vicompany2018}.
In 2019 and 2020, after several crashes~\autocite{Campbell2019},
the Boeing 737 Max was grounded to fix existing problems, while grounded,
more software-related issues were
found~\autocite{Okane2019,Okane2020},
delaying its re-certification.
In 2020, as the number of COVID-19 grew,
contact tracing apps were deployed as a mitigation strategy.
The UK's National Health Service app failed to ask users to self-isolate due to a
bug~\autocite{Mageit2020}.

The previous examples are not isolated incidents, the language and nature of the bugs is different for each case,
to put it simply, there is no silver bullet and the next best alternative is to do our best to mitigate them by
building tools and abstractions which allow developers to increase their code's safety.

\section{Problem}

Languages like C/C++ have dominated the systems programming landscape for years and
one of the main problems with both is the lack of memory management.
Leaving such responsibility to the developer has proven to be \emph{a less than ideal}
solution, with $70\%$ of bugs in projects like Chromium~\autocite{chromium}
and Microsoft products~\autocite{Miller2019} being due to memory management.

To address such problem, several tools and languages have been and continue to be developed,
so far, Rust has been the only one to achieve \emph{mainstream} status.
Rust aims to provide memory safety without affecting performance or productivity,
to achieve such ambitious goal, Rust validates code with the borrow checker, which then enforces memory safety rules,
targeting the problem at its root.

Addressing memory safety is not enough though,
languages which side-step the problem of having manual management
through the use of a garbage collector (e.g. Java and Go) still suffer from other kinds bugs.
As discussed in the end of \autoref{sec:context}, we can only mitigate their occurrence, and
so we are required to reach out to new mechanisms.

Typestates are an approach which aims to tame stateful computations,
to do so typestates lift the concept of state to the type level,
this enables the compiler to reason about state and provides the developer
with information of the expected computation state at runtime.

Consider Java's \keyword{Scanner}, its API allows the developer to write code like \autoref{lst:java-scanner},
which will compile without issuing any errors or warnings (even with the \texttt{-Xlint:all} flag).
The example in \autoref{lst:java-scanner} will crash during runtime, since it is not possible to read from a closed source,
the thrown exception is \texttt{IllegalStateException}.
Informing the user that the attempted operation is illegal for the current object state,
ideally we want such illegal states to be detected at compile time.

\begin{listing}
    \begin{minted}{java}
Scanner s = new Scanner(System.in);         // open the stream
s.nextLine();                               // read
s.close();                                  // close the stream
s.nextLine();                               // IllegalStateException
    \end{minted}
    \caption{Java's \keyword{Scanner} misuse example.}
    \label{lst:java-scanner}
\end{listing}

If we consider a typestated language, as in \autoref{lst:java-scanner-typestate},
the code allows us to trace the state of the object, but even better,
the compiler is now able to tell us there is an error during compilation.

\begin{listing}
    \begin{minted}{java}
Scanner[Open] s = new Scanner(System.in);   // open the stream
s.nextLine();                               // read
Scanner[Closed] s = s.close();              // close the stream
s.nextLine();                               // compile-time error
    \end{minted}
    \caption{
        Typestated \keyword{Scanner} example.
        Notice how the compiler is able to detect the error.
    }
    \label{lst:java-scanner-typestate}
\end{listing}

\section{State of the Art}

% We now present a shallow review over their usefulness,
% possible approaches to typestates and challenges faced when adding typestates to a language.

% % \subsection{What are Typestates?}\label{sec:typestates:what-are-typestates}

% \subsection{Why are Typestates useful?}\label{sec:typestates:why-are-typestates-useful}

% Typestates allow the developer to provide more expressive APIs, as well as securer ones.
% Currently, in \emph{typestateless} programming,
% programmers are required to track object state in their heads, with the help of comments,
% the code itself and possibly the debugger, running the code and checking their assumptions by hand.



% \subsection{Approaches}

% As previously discussed, simply put, typestates are the elevation of state to the type system.
% Currently, there are three main approaches to typestates,
% some can be retrofitted into existing languages.

% \paragraph{State-Based Design}
% This is the most common approach, able to be used in any language,
% essentially, all responsibility is on the developer, which is required to track state at runtime by adding
% state checking barriers (e.g. \texttt{if CurrentState == DesiredState}).
% In such case, state modelling will be done using enumerations or the language equivalent.

% \paragraph{Typestate Checkers}
% Typestate checkers are external tools to the language,
% they may take the form of an independent tool or a compiler plugin.
% Their goal is to run as part of the compilation stage and enforce the desired state transitions in the code.
% The biggest problem with tools like these,
% is the added complexity of extra tools over the build process.

% \paragraph{Language-Based}
% The language-based approach is the most solid approach to the problem.
% At a conceptual level it is also the simplest approach,
% instead of adding features to existing languages just to enable typestate support,
% it prioritizes typestates and makes them a first-class language construct.
% This approach is the one taken by languages such as \todo{Add ref}[Plaid].


% \subsection{Challenges}

% Typestates are not without their challenges,
% attentive readers might notice that if objects are mutably aliased,
% typestate guarantees cannot hold since the object can be mutated,
% changing state while a client depends on the previous one.

% \missingfigure{Picture which exemplifies the mutable alias problem.}

% Solving this problem requires objects to be owned by a single client,
% this is due to the fact that even if an immutable alias exists,
% its type may be mutated by the original owner.

% \todo{Verify this with the advisor}Such solution requires the type system to be at least affine,
% being able to enforce a \emph{use at most once} policy over the language objects.

% % \section{State Machines}\label{sec:state-machines}

% % \section{What is the relation between them?}\label{sec:ts-fsm-relation}

% \section{The Rust Language}\label{sec:rust}

% \subsection{Why Rust?}\label{sec:rust:why}


\section{Objectives and expected contributions}