% Encoding: UTF-8

@InProceedings{Strom1983,
  author    = {Strom, Robert E.},
  booktitle = {Proceedings of the 10th ACM SIGACT-SIGPLAN symposium on Principles of programming languages - POPL '83},
  title     = {{Mechanisms for compile-time enforcement of security}},
  year      = {1983},
  address   = {New York, New York, USA},
  pages     = {276--284},
  publisher = {ACM Press},
  doi       = {10.1145/567067.567093},
  file      = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/strom1983.pdf:pdf},
  groups    = {Articles},
  isbn      = {0897910907},
  url       = {http://portal.acm.org/citation.cfm?doid=567067.567093},
}

@Book{Stroustrup1986,
  author   = {Stroustrup, Bjarne},
  title    = {{The C ++ Programming}},
  year     = {1986},
  isbn     = {978-0321563842},
  abstract = {The new C++11 standard allows programmers to express ideas more clearly, simply, and directly, and to write faster, more efficient code. Bjarne Stroustrup, the designer and original implementer of C++, has reorganized, extended, and completely rewritten his definitive reference and tutorial for programmers who want to use C++ most effectively.},
  file     = {:home/jmgd/Documents/work/msc/biblio/Stroustrup B. - The C++ Programming Language, 4th Edition (2013, Addison Wesley) - libgen.lc.pdf:pdf},
  groups   = {Articles},
  pages    = {1346},
}

@Article{Strom1986,
  author   = {Strom, Robert E. and Yemini, Shaula},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {{Typestate: A Programming Language Concept for Enhancing Software Reliability}},
  year     = {1986},
  issn     = {00985589},
  number   = {1},
  pages    = {157--171},
  volume   = {SE-12},
  abstract = {We introduce a new programming language concept called typestate, which is a refinement of the concept of type. Whereas the type of a data object determines the set of operations ever permitted on the object, typestate determines the subset of these operations which is permitted in a particular context. Typestate tracking is a program analysis technique which enhances program reliability by detecting at compile-time syntactically legal but semantically undefined execution sequences. These include, for example, reading a variable before it has been initialized, dereferencing a pointer after the dynamic object has been deallocated, etc. Typestate tracking detects errors that cannot be detected by type checking or by conventional static scope rules. Additionally, typestate tracking makes it possible for compilers to insert appropriate finalization of data at exception points and on program termination, eliminating the need to support finalization by means of either garbage collection or unsafe deallocation operations such as Pascal's dispose operation. By enforcing typestate invariants at compile-time, it becomes practical to implement a “secure language''—that is, one in which all successfully compiled program modules have fully defined execution-time effects, and the only effects of program errors are incorrect output values. This paper defines typestate, gives examples of its application, and shows how typestate checking may be embedded into a compiler. We discuss the consequences of typestate checking for software reliability and software structure, and conclude with a discussion of our experience using a high-level language incorporating typestate checking. {\textcopyright} 1986 IEEE},
  doi      = {10.1109/TSE.1986.6312929},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/hermes/strom1986.pdf:pdf},
  groups   = {Articles},
  keywords = {Program analysis,program verification,securitv,software reliability,type checking,typestate},
}

@Book{BrianW.Kernighan1988,
  author    = {{Brian W. Kernighan}, Dennis M Ritchie},
  publisher = {Prentice Hall},
  title     = {{The ANSI C Programming Language}},
  year      = {1988},
  edition   = {2},
  isbn      = {9780131103627,0131103628},
  groups    = {Articles},
}

@Book{Strom1990,
  author = {Strom, Robert E and Goldberg, Arthur P and Bacon, David F and Lowry, Andy},
  title  = {{Hermes : A Tutorial and Reference Manual}},
  year   = {1990},
  file   = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/hermes/Strom90HermesTutorial.pdf:pdf},
  groups = {Articles},
  url    = {https://researcher.watson.ibm.com/researcher/files/us-bacon/Strom90HermesTutorial.pdf},
}

@Article{Honda1993,
  author  = {Honda, Kohei},
  journal = {October},
  title   = {{Types for Dyadic Interaction 2 Typed Terms}},
  year    = {1993},
  number  = {April 1992},
  pages   = {1--17},
  file    = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/dyadic-inter-1993.pdf:pdf},
  groups  = {Articles},
}

@Article{Honda1998,
  author   = {Honda, Kohei and Vasconcelos, Vasco T. and Kubo, Makoto},
  journal  = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  title    = {{Language primitives and type discipline for structured communication-based programming}},
  year     = {1998},
  issn     = {16113349},
  pages    = {122--138},
  volume   = {1381},
  abstract = {We introduce basic language constructs and a type discipline as a found­ation of structured communication-based concurrent programming. The constructs, which are easily translatable into the summation-less asynchronous 7r-calculus, allow programmers to organise programs as a combination of multiple flows of (possibly unbounded) reciprocal interactions in a simple and elegant way, subsuming the pre­ceding communication primitives such as method invocation and rendez-vous. The resulting syntactic structure is exploited by a type discipline a la ML, which offers a high-level type abstraction of interactive behaviours of programs as well as guar­anteeing the compatibility of interaction patterns between processes in a well-typed program. After presenting the formal semantics, the use of language constructs is illustrated through examples, and the basic syntactic results of the type discipline are established. Implementation concerns are also addressed.},
  doi      = {10.1007/bfb0053567},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/Honda1998{\_}Chapter{\_}LanguagePrimitivesAndTypeDisci.pdf:pdf},
  groups   = {Articles},
  isbn     = {3540643028},
}

@Article{Cardelli2004,
  author   = {Cardelli, Luca},
  journal  = {Computer Science Handbook, Second Edition},
  title    = {{Type systems}},
  year     = {2004},
  issn     = {0360-0300},
  pages    = {97--1--97--32},
  abstract = {The fundamental purpose of a type system is to prevent the occurrence of execution errors during the running of a program. This informal statement motivates the study of type systems, but requires clarification. Its accuracy depends, first of all, on the rather subtle issue of what constitutes an execution error, which we will discuss in detail. Even when that is settled, the absence of execution errors is a nontrivial property. When such a property holds for all the program runs that can be expressed within a programming language, we say that the language is type sound. It turns out that a fair amount of careful analysis is required to avoid false and embarrassing claims of type soundness for programming languages. As a consequence, the classification, description, and study of type systems has emerged as a formal discipline.},
  doi      = {10.1201/9781420043839.ch9},
  file     = {:home/jmgd/Documents/work/msc/biblio/type-systems/TypeSystems.pdf:pdf},
  groups   = {Articles},
  isbn     = {9780203494455},
}

@Article{DeLine2004,
  author   = {DeLine, Robert and F{\"{a}}hndrich, Manuel},
  journal  = {Submitted manuscript},
  title    = {{The Fugue protocol checker: Is your software Baroque?}},
  year     = {2004},
  number   = {January},
  abstract = {Even in a safe programming language, such as C♯ or Java, disobeying the rules for using an interface can cause exceptions at run time. Such rules govern how system resources are managed, the order of method calls, and the formatting of string parameters, such as SQL queries. This paper introduces Fugue, a modular static checker for languages that compile to the Common Language Runtime. Fugue allows the rules for using an interface to be recorded as declarative specifications and provides a range of annotations that allow a developer to specify interface rule with varying precision. At the simplest end of the range, a specifier can mark those methods that allocate and release resources. A specifier can also limit the order in which an object's methods may be called to the transitions of a finite state machine. At the most complex end of the range, a specifier can give a method a plug-in pre- and postconditon, which is arbitrary code that examines an object's current state and a static approximation of the method's actuals, decides whether the call is legal and returns the object's state after the call. We used these features to specify rules for using ADO.NET, a library for accessing relational databases, and found several errors in an internal Microsoft Research web site, which extensively uses this library.},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/fugue-2004.pdf:pdf},
  groups   = {Articles},
  url      = {http://research.microsoft.com/apps/pubs/default.aspx?id=67458{\%}5Cnhttp://research.microsoft.com/en-us/projects/fugue/},
}

@Article{Deline2004,
  author   = {Deline, Robert and F{\"{a}}hndrich, Manuel},
  journal  = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  title    = {{Typestates for Objects}},
  year     = {2004},
  issn     = {16113349},
  pages    = {465--490},
  volume   = {3086},
  abstract = {Today's mainstream object-oriented compilers and tools do not support declaring and statically checking simple pre- and postconditions on methods and invariants on object representations. The main technical problem preventing static verification is reasoning about the sharing relationships among objects as well as where object invariants should hold. We have developed a programming model of typestates for objects with a sound modular checking algorithm. The programming model handles typical aspects of object-oriented programs such as downcasting, virtual dispatch, direct calls, and subclassing. The model also permits subclasses to extend the interpretation of typestates and to introduce additional typestates. We handle aliasing by adapting our previous work on practical linear types developed in the context of the Vault system. We have implemented these ideas in a tool called Fugue for specifying and checking typestates on Microsoft .NET-based programs. {\textcopyright} Springer-Verlag 2004.},
  doi      = {10.1007/978-3-540-24851-4_21},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/deline-typestates.pdf:pdf},
  groups   = {Articles},
  isbn     = {354022159X},
}

@Article{Vasconcelos2006,
  author   = {Vasconcelos, Vasco T. and Gay, Simon J. and Ravara, Ant{\'{o}}nio},
  journal  = {Theoretical Computer Science},
  title    = {{Type checking a multithreaded functional language with session types}},
  year     = {2006},
  issn     = {03043975},
  number   = {1-2},
  pages    = {64--87},
  volume   = {368},
  abstract = {We define a language whose type system, incorporating session types, allows complex protocols to be specified by types and verified by static type checking. A session type, associated with a communication channel, specifies the state transitions of a protocol and also the data types of messages associated with transitions; thus type checking can verify both correctness of individual messages and correctness of sequences of transitions. Previously, session types have mainly been studied in the context of the $\pi$-calculus; instead, our formulation is based on a multithreaded functional language with side-effecting input/output operations. Our typing judgements statically describe dynamic changes in the types of channels, and our function types not only specify argument and result types but also describe changes in channels. We formalize the syntax, semantics and type checking system of our language, and prove subject reduction and runtime type safety theorems. {\textcopyright} 2006 Elsevier B.V. All rights reserved.},
  doi      = {10.1016/j.tcs.2006.06.028},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/10.1016{\_}j.tcs.2006.06.028.pdf:pdf},
  groups   = {Articles},
  keywords = {Concurrent programming,Session types,Specification of communication protocols,Static type checking},
}

@Article{Hu2008,
  author   = {Hu, Raymond and Yoshida, Nobuko and Honda, Kohei},
  journal  = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  title    = {{Session-based distributed programming in Java}},
  year     = {2008},
  issn     = {03029743},
  pages    = {516--541},
  volume   = {5142 LNCS},
  abstract = {This paper demonstrates the impact of integrating session types and object-oriented programming, through their implementation in Java. Session types provide high-level abstraction for structuring a series of interactions in a concise syntax, and ensure type-safe communications between distributed peers. We present the first full implementation of a language and runtime for session-based distributed programming featuring asynchronous message passing, delegation, and session subtyping and interleaving, combined with class downloading and failure handling. The compilation-runtime framework of our language effectively maps session abstraction onto underlying transports and guarantees communication safety through static and dynamic session type checking. We have implemented two alternative mechanisms for performing distributed session delegation and prove their correctness. Benchmark results show session abstraction can be realised with low runtime overhead. {\textcopyright} 2008 Springer-Verlag.},
  doi      = {10.1007/978-3-540-70592-5_22},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/hu07-sessionj.pdf:pdf},
  groups   = {Articles},
  isbn     = {3540705910},
}

@Article{Stork2009,
  author   = {Stork, Sven and Marques, Paulo and Aldrich, Jonathan},
  journal  = {Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, OOPSLA},
  title    = {{Concurrency by default: Using permissions to express dataflow in stateful programs}},
  year     = {2009},
  pages    = {933--940},
  abstract = {The rise of the multicore era is catapulting concurrency into mainstream programming. Current programming paradigms build in sequentiality, and as a result, concurrency support in those languages forces programmers into low-level reasoning about execution order. In this paper, we introduce a new programming paradigm in which concurrency is the default. Our Aeminium language uses access permissions to express logical dependencies in the code at a higher level of abstraction than sequential order. Therefore compiler/runtime-system can leverage that dependency information to allow concurrent execution. Because in Aeminium programmers specify dependencies rather than control flow, there is no need to engage in difficult, error-prone, and low-level reasoning about execution order or thread interleavings. Developers can instead focus on the design of the program, and benefit as the runtime automatically extracts the concurrency inherent in their design. Copyright {\textcopyright} 2009 ACM.},
  doi      = {10.1145/1639950.1640060},
  file     = {:home/jmgd/Documents/work/msc/biblio/onward2009-concurrency.pdf:pdf},
  groups   = {Articles},
  isbn     = {9781605587660},
  keywords = {Access permissions,Concurrency,Dataflow,Programming language},
}

@InProceedings{Aldrich2009,
  author    = {Aldrich, Jonathan and Sunshine, Joshua and Saini, Darpan and Sparks, Zachary},
  booktitle = {Proceeding of the 24th ACM SIGPLAN conference companion on Object oriented programming systems languages and applications - OOPSLA '09},
  title     = {{Typestate-oriented programming}},
  year      = {2009},
  address   = {New York, New York, USA},
  pages     = {1015},
  publisher = {ACM Press},
  doi       = {10.1145/1639950.1640073},
  file      = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/onward2009-state.pdf:pdf},
  groups    = {Articles},
  isbn      = {9781605587684},
  url       = {http://www.cs.cmu.edu/{~}aldrich/papers/onward2009-state.pdf http://dl.acm.org/citation.cfm?doid=1639950.1640073},
}

@Article{Campos2011,
  author   = {Campos, Joana and Vasconcelos, Vasco T.},
  journal  = {Electronic Proceedings in Theoretical Computer Science},
  title    = {{Channels as Objects in Concurrent Object-Oriented Programming}},
  year     = {2011},
  issn     = {2075-2180},
  pages    = {12--28},
  volume   = {69},
  abstract = {There is often a sort of a protocol associated to each class, stating when and how certain methods should be called. Given that this protocol is, if at all, described in the documentation accompanying the class, current mainstream object-oriented languages cannot provide for the verification of client code adherence against the sought class behaviour. We have defined a class-based concurrent object-oriented language that formalises such protocols in the form of usage types. Usage types are attached to class definitions, allowing for the specification of (1) the available methods, (2) the tests clients must perform on the result of methods, and (3) the object status-linear or shared-all of which depend on the object's state. Our work extends the recent approach on modular session types by eliminating channel operations, and defining the method call as the single communication primitive in both sequential and concurrent settings. In contrast to previous works, we define a single category for objects, instead of distinct categories for linear and for shared objects, and let linear objects evolve into shared ones. We introduce a standard sync qualifier to prevent thread interference in certain operations on shared objects. We formalise the language syntax, the operational semantics, and a type system that enforces by static typing that methods are called only when available, and by a single client if so specified in the usage type. We illustrate the language via a complete example.},
  doi      = {10.4204/eptcs.69.2},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mool/1110.4157v1.pdf:pdf},
  groups   = {Articles},
}

@Article{Padovani2011,
  author   = {Padovani, Luca},
  journal  = {Electronic Proceedings in Theoretical Computer Science},
  title    = {{Session Types = Intersection Types + Union Types}},
  year     = {2011},
  issn     = {2075-2180},
  number   = {Itrs 2010},
  pages    = {71--89},
  volume   = {45},
  abstract = {We propose a semantically grounded theory of session types which relies on intersection and union types. We argue that intersection and union types are natural candidates for modeling branching points in session types and we show that the resulting theory overcomes some important defects of related behavioral theories. In particular, intersections and unions provide a native solution to the problem of computing joins and meets of session types. Also, the subtyping relation turns out to be a pre-congruence, while this is not always the case in related behavioral theories.},
  doi      = {10.4204/eptcs.45.6},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/1101.4429.pdf:pdf},
  groups   = {Articles},
}

@InCollection{Toninho2013,
  author = {Toninho, Bernardo and Caires, Luis and Pfenning, Frank},
  title  = {{Higher-Order Processes, Functions, and Sessions: A Monadic Integration}},
  year   = {2013},
  pages  = {350--369},
  doi    = {10.1007/978-3-642-37036-6_20},
  file   = {:home/jmgd/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Toninho, Caires, Pfenning - 2013 - Higher-Order Processes, Functions, and Sessions A Monadic Integration.pdf:pdf},
  groups = {Articles},
  url    = {http://link.springer.com/10.1007/978-3-642-37036-6{\_}20},
}

@Article{Yoshida2014,
  author   = {Yoshida, Nobuko and Hu, Raymond and Neykova, Rumyana and Ng, Nicholas},
  journal  = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  title    = {{The scribble protocol language}},
  year     = {2014},
  issn     = {16113349},
  number   = {October 2007},
  pages    = {22--41},
  volume   = {8358 LNCS},
  abstract = {This paper describes a brief history of how Kohei Honda initiated the Scribble project, and summarises the current status of Scribble. {\textcopyright} Springer International Publishing Switzerland 2014.},
  doi      = {10.1007/978-3-319-05119-2_3},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/yoshida2014.pdf:pdf},
  groups   = {Articles},
  isbn     = {9783319051185},
}

@Article{Garcia2014,
  author  = {Garcia, Ronald and Tanter, {\'{E}}ric and Wolff, Roger and Aldrich, Jonathan},
  journal = {ACM Transactions on Programming Languages and Systems},
  title   = {{Foundations of Typestate-Oriented Programming}},
  year    = {2014},
  issn    = {0164-0925},
  month   = {oct},
  number  = {4},
  pages   = {1--44},
  volume  = {36},
  doi     = {10.1145/2629609},
  file    = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/10.1145{\_}2629609.pdf:pdf},
  groups  = {Articles},
  url     = {https://dl.acm.org/doi/10.1145/2629609},
}

@Article{Gay2015,
  author   = {Gay, Simon J. and Gesbert, Nils and Ravara, Ant{\'{o}}nio and Vasconcelos, Vasco T.},
  journal  = {Logical Methods in Computer Science},
  title    = {{Modular session types for objects}},
  year     = {2015},
  issn     = {18605974},
  number   = {4},
  pages    = {1--76},
  volume   = {11},
  abstract = {Session types allow communication protocols to be specified type-theoretically so that protocol implementations can be verified by static type checking. We extend previous work on session types for distributed object-oriented languages in three ways. (1) We attach a session type to a class definition, to specify the possible sequences of method calls. (2) We allow a session type (protocol) implementation to be modularized, i.e. partitioned into separately-callable methods. (3) We treat session-typed communication channels as objects, integrating their session types with the session types of classes. The result is an elegant unification of communication channels and their session types, distributed object-oriented programming, and a form of typestate supporting non-uniform objects, i.e. objects that dynamically change the set of available methods. We define syntax, operational semantics, a sound type system, and a sound and complete type checking algorithm for a small distributed class-based object-oriented language with structural subtyping. Static typing guarantees that both sequences of messages on channels, and sequences of method calls on objects, conform to type-theoretic specifications, thus ensuring type-safety. The language includes expected features of session types, such as delegation, and expected features of object-oriented programming, such as encapsulation of local state.},
  doi      = {10.2168/LMCS-11(4:12)2015},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/modular-session-2015.pdf:pdf},
  groups   = {Articles},
  keywords = {Non-uniform method availability,Object-oriented calculus,Session types,Typestate},
}

@Article{Jespersen2015,
  author   = {Jespersen, Thomas Bracht Laumann and Munksgaard, Philip and Larsen, Ken Friis},
  journal  = {WGP 2015 - Proceedings of the 11th ACM SIGPLAN Workshop on Generic Programming, co-located with ICFP 2015},
  title    = {{Session types for rust}},
  year     = {2015},
  pages    = {13--22},
  abstract = {We present a library for specifying session types implemented in Rust, and discuss practical use cases through examples and demonstrate how session types may be used in a large-scale application. Specifically we adapt parts of the ad-hoc communication patterns in the Servo browser engine to use session typed channels. Session types provide a protocol abstraction, expanding on traditional typed communication channels, to ensure that communication takes place according to a specified protocol. Thus, the library allows us to provide compile-time guarantees of adherence to a specific protocol without incurring significant run-time penalties.},
  doi      = {10.1145/2808098.2808100},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/laumann-munksgaard-larsen.pdf:pdf},
  groups   = {Articles},
  isbn     = {9781450338103},
  keywords = {Concurrency,Generic types,Rust,Session types},
}

@Article{Vasconcelos2016,
  author        = {Vasconcelos, Cl{\'{a}}udio and Ravara, Ant{\'{o}}nio},
  title         = {{A Revision of the Mool Language}},
  year          = {2016},
  pages         = {1--34},
  abstract      = {We present here in a thorough analysis of the Mool language, covering not only its implementation but also the formalisation (syntax, operational semantics, and type system). The objective is to detect glitches in both the implementation and in the formal definitions, proposing as well new features and added expressiveness. To test our proposals we implemented the revision developed in the Racket platform.},
  archiveprefix = {arXiv},
  arxivid       = {1604.06245},
  eprint        = {1604.06245},
  file          = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mool/1604.06245.pdf:pdf},
  groups        = {Articles},
  url           = {http://arxiv.org/abs/1604.06245},
}

@InProceedings{Klabnik2016,
  author    = {Klabnik, Steve},
  booktitle = {Applicative 2016 on - Applicative 2016},
  title     = {{The History of Rust}},
  year      = {2016},
  address   = {New York, New York, USA},
  pages     = {80},
  publisher = {ACM Press},
  doi       = {10.1145/2959689.2960081},
  groups    = {Articles},
  isbn      = {9781450344647},
  url       = {http://dl.acm.org/citation.cfm?doid=2959689.2960081},
}

@Article{Ancona2016,
  author   = {Ancona, Davide and Bono, Viviana and Bravetti, Mario and Campos, Joana and Castagna, Giuseppe and Deni{\'{e}}lou, Pierre Malo and Gay, Simon J. and Gesbert, Nils and Giachino, Elena and Hu, Raymond and Johnsen, Einar Broch and Martins, Francisco and Mascardi, Viviana and Montesi, Fabrizio and Neykova, Rumyana and Ng, Nicholas and Padovani, Luca and Vasconcelos, Vasco T. and Yoshida, Nobuko},
  journal  = {Foundations and Trends in Programming Languages},
  title    = {{Behavioral types in programming languages}},
  year     = {2016},
  issn     = {23251131},
  number   = {2-3},
  pages    = {95--230},
  volume   = {3},
  abstract = {A recent trend in programming language research is to use behavioral type theory to ensure various correctness properties of large-scale, communication-intensive systems. Behavioral types encompass concepts such as interfaces, communication protocols, contracts, and choreography. The successful application of behavioral types requires a solid understanding of several practical aspects, from their representation in a concrete programming language, to their integration with other programming constructs such as methods and functions, to design and monitoring methodologies that take behaviors into account. This survey provides an overview of the state of the art of these aspects, which we summarize as the pragmatics of behavioral types.},
  doi      = {10.1561/2500000031},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/ancona2016.pdf:pdf},
  groups   = {Articles},
}

@Article{Huettel2016,
  author   = {H{\"{u}}ttel, Hans and Lanese, Ivan and Vasconcelos, Vasco T. and Caires, L{\'{u}}is and Carbone, Mmarco and Deni{\'{e}}lou, Pierre Malo and Mostrous, Dimitris and Padovani, Luca and Ni{\'{o}}ravara, Ant{\'{o}} and Tuosto, Emilio and Vieira, Hugo Torres and Zavattaro, Gianluigi},
  journal  = {ACM Computing Surveys},
  title    = {{Foundations of session types and behavioural contracts}},
  year     = {2016},
  issn     = {15577341},
  number   = {1},
  pages    = {1--36},
  volume   = {49},
  abstract = {Behavioural type systems, usually associated to concurrent or distributed computations, encompass concepts such as interfaces, communication protocols, and contracts, in addition to the traditional input/output operations. The behavioural type of a software component specifies its expected patterns of interaction using expressive type languages, so types can be used to determine automatically whether the component interacts correctly with other components. Two related important notions of behavioural types are those of session types and behavioural contracts. This article surveys the main accomplishments of the last 20 years within these two approaches.},
  doi      = {10.1145/2873052},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/2873052.pdf:pdf},
  groups   = {Articles},
  keywords = {Behavioural types},
}

@Article{Xi2016a,
  author        = {Xi, Hongwei and Wu, Hanwen},
  title         = {{Linearly Typed Dyadic Group Sessions for Building Multiparty Sessions}},
  year          = {2016},
  abstract      = {Traditionally, each party in a (dyadic or multiparty) session implements exactly one role specified in the type of the session. We refer to this kind of session as an individual session (i-session). As a generalization of i-session, a group session (g-session) is one in which each party may implement a group of roles based on one channel. In particular, each of the two parties involved in a dyadic g-session implements either a group of roles or its complement. In this paper, we present a formalization of g-sessions in a multi-threaded lambda-calculus (MTLC) equipped with a linear type system, establishing for the MTLC both type preservation and global progress. As this formulated MTLC can be readily embedded into ATS, a full-fledged language with a functional programming core that supports both dependent types (of DML-style) and linear types, we obtain a direct implementation of linearly typed g-sessions in ATS. The primary contribution of the paper lies in both of the identification of g-sessions as a fundamental building block for multiparty sessions and the theoretical development in support of this identification.},
  archiveprefix = {arXiv},
  arxivid       = {1604.03020},
  eprint        = {1604.03020},
  file          = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/ats/1604.03020.pdf:pdf},
  groups        = {Articles},
  keywords      = {Computer Science - Programming Languages},
}

@Article{Xi2016,
  author        = {Xi, Hongwei and Ren, Zhiqiang and Wu, Hanwen and Blair, William},
  title         = {{Session Types in a Linearly Typed Multi-Threaded Lambda-Calculus}},
  year          = {2016},
  abstract      = {We present a formalization of session types in a multi-threaded lambda-calculus (MTLC) equipped with a linear type system, establishing for the MTLC both type preservation and global progress. The latter (global progress) implies that the evaluation of a well-typed program in the MTLC can never reach a deadlock. As this formulated MTLC can be readily embedded into ATS, a full-fledged language with a functional programming core that supports both dependent types (of DML-style) and linear types, we obtain a direct implementation of session types in ATS. In addition, we gain immediate support for a form of dependent session types based on this embedding into ATS. Compared to various existing formalizations of session types, we see the one given in this paper is unique in its closeness to concrete implementation. In particular, we report such an implementation ready for practical use that generates Erlang code from well-typed ATS source (making use of session types), thus taking great advantage of the infrastructural support for distributed computing in Erlang.},
  archiveprefix = {arXiv},
  arxivid       = {1603.03727},
  eprint        = {1603.03727},
  file          = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/ats/1603.03727.pdf:pdf},
  groups        = {Articles},
  keywords      = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
}

@Article{Bezanson2017,
  author        = {Bezanson, Jeff and Edelman, Alan and Karpinski, Stefan and Shah, Viral B.},
  journal       = {SIAM Review},
  title         = {{Julia: A fresh approach to numerical computing}},
  year          = {2017},
  issn          = {00361445},
  number        = {1},
  pages         = {65--98},
  volume        = {59},
  abstract      = {Bridging cultures that have often been distant, Julia combines expertise from the diverse helds of computer science and computational science to create a new approach to numerical computing. Julia is designed to be easy and fast and questions notions generally held to be "laws of nature" by practitioners of numerical computing: 1. High-level dynamic programs have to be slow. 2. One must prototype in one language and then rewrite in another language for speed or deployment. 3. There are parts of a system appropriate for the programmer, and other parts that are best left untouched as they have been built by the experts. We introduce the Julia programming language and its design-a dance between specialization and abstraction. Specialization allows for custom treatment. Multiple dispatch, a technique from computer science, picks the right algorithm for the right circumstance. Abstraction, which is what good computation is really about, recognizes what remains the same after differences are stripped away. Abstractions in mathematics are captured as code through another technique from computer science, generic programming. Julia shows that one can achieve machine performance without sacrificing human convenience.},
  archiveprefix = {arXiv},
  arxivid       = {1411.1607},
  doi           = {10.1137/141000671},
  eprint        = {1411.1607},
  file          = {:home/jmgd/Documents/work/msc/biblio/julia-fresh-approach-BEKS.pdf:pdf},
  groups        = {Articles},
  keywords      = {Julia,Numerical,Parallel,Scientific computing},
}

@Article{Vasconcelos2017,
  author   = {Vasconcelos, Cl{\'{a}}udio and Ravara, Ant{\'{o}}nio},
  journal  = {Proceedings of the ACM Symposium on Applied Computing},
  title    = {{From object-oriented code with assertions to behavioural types}},
  year     = {2017},
  pages    = {1492--1497},
  volume   = {Part F1280},
  abstract = {The widespread use of service-oriented and cloud computing is creating a need for a communication-based programming approach to distributed concurrent software systems. Protocols play a central role in the design and development of such systems but mainstream programming languages still give poor support to ensure protocol compatibility. Testing alone is insufficient to ensure it, so there is a pressing need for tools to assist the development of these kind of systems. While there are tools to verify statically objectoriented code equipped with assertions, these mainly help to prevent runtime errors. However, a program can be illbehaved and still execute without terminating abruptly. It is important to guarantee that the code implements correctly its communication protocol. Our contribution is a tool to analyse source code written in a subset of Java, equipped with assertions, and return it annotated with its respective behavioural types that can be used to verify statically that the code implements the intended protocol of the application. A running example illustrates each step of the tool.},
  doi      = {10.1145/3019612.3019733},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mool/3019612.3019733.pdf:pdf},
  groups   = {Articles},
  isbn     = {9781450344869},
  keywords = {Assertions,Behavioural types,Object-oriented programming},
}

@Book{Gay2017,
  author    = {Gay, Simon and Ravara, Ant{\'{o}}nio},
  title     = {{Behavioural types: From theory to tools english}},
  year      = {2017},
  isbn      = {9788793519817},
  abstract  = {Behavioural type systems in programming languages support the specification and verification of properties of programs beyond the traditional use of type systems to describe data processing. A major example of such a property is correctness of communication in concurrent and distributed systems, motivated by the importance of structured communication in modern software. Behavioural Types: from Theory to Tools presents programming languages and software tools produced by members of COST Action IC1201: Behavioural Types for Reliable Large-Scale Software Systems, a European research network that was funded from October 2012 to October 2016. As a survey of the most recent developments in the application of behavioural type systems, it is a valuable reference for researchers in the field, as well as an introduction to the area for graduate students and software developers.},
  booktitle = {Behavioural Types: from Theory to Tools English},
  doi       = {10.13052/rp-9788793519817},
  file      = {:home/jmgd/Documents/work/msc/biblio/behavioral/RE{\_}9788793519817.pdf:pdf},
  groups    = {Articles},
  pages     = {1--375},
}

@Article{Kouzapas2018,
  author    = {Kouzapas, Dimitrios and Dardha, Ornela and Perera, Roly and Gay, Simon J.},
  journal   = {Science of Computer Programming},
  title     = {{Typechecking protocols with Mungo and StMungo: A session type toolchain for Java}},
  year      = {2018},
  issn      = {01676423},
  pages     = {52--75},
  volume    = {155},
  abstract  = {Static typechecking is an important feature of many standard programming languages. However, static typing focuses on data rather than communication, and therefore does not help programmers correctly implement communication protocols in distributed systems. The theory of session types provides a basis for tackling this problem; we use it to develop two tools that support static typechecking of communication protocols in Java. The first tool, Mungo, extends Java with typestate definitions, which allow classes to be associated with state machines defining permitted sequences of method calls: for example, communication methods. The second tool, StMungo, takes a session type describing a communication protocol, and generates a typestate specification of the permitted sequences of messages in the protocol. Protocol implementations can be validated by Mungo against their typestate definitions and then compiled with a standard Java compiler. The result is a toolchain for static typechecking of communication protocols in Java. We formalise and prove soundness of the typestate inference system used by Mungo, and show that our toolchain can be used to typecheck a client for the standard Simple Mail Transfer Protocol (SMTP).},
  doi       = {10.1016/j.scico.2017.10.006},
  file      = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mungo/1-s2.0-S0167642317302186-main.pdf:pdf},
  groups    = {Articles},
  keywords  = {Object-oriented programming,Session types,Type inference,Typestate},
  publisher = {Elsevier B.V.},
  url       = {https://doi.org/10.1016/j.scico.2017.10.006},
}

@Article{Coblenz2020a,
  author        = {Coblenz, Michael and Oei, Reed and Etzel, Tyler and Koronkevich, Paulette and Baker, Miles and Bloem, Yannick and Myers, Brad A. and Sunshine, Joshua and Aldrich, Jonathan},
  journal       = {ACM Transactions on Programming Languages and Systems},
  title         = {{Obsidian: Typestate and assets for safer blockchain programming}},
  year          = {2020},
  issn          = {15584593},
  number        = {3},
  volume        = {42},
  abstract      = {Blockchain platforms are coming into use for processing critical transactions among participants who have not established mutual trust. Many blockchains are programmable, supporting smart contracts, which maintain persistent state and support transactions that transform the state. Unfortunately, bugs in many smart contracts have been exploited by hackers. Obsidian is a novel programming language with a type system that enables static detection of bugs that are common in smart contracts today. Obsidian is based on a core calculus, Silica, for which we proved type soundness. Obsidian uses typestate to detect improper state manipulation and uses linear types to detect abuse of assets. We integrated a permissions system that encodes a notion of ownership to allow for safe, flexible aliasing. We describe two case studies that evaluate Obsidian's applicability to the domains of parametric insurance and supply chain management, finding that Obsidian's type system facilitates reasoning about high-level states and ownership of resources. We compared our Obsidian implementation to a Solidity implementation, observing that the Solidity implementation requires much boilerplate checking and tracking of state, whereas Obsidian does this work statically.},
  archiveprefix = {arXiv},
  arxivid       = {1909.03523},
  doi           = {10.1145/3417516},
  eprint        = {1909.03523},
  file          = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/obsidian.pdf:pdf},
  groups        = {Articles},
  keywords      = {Typestate,alias control,blockchain,linearity,ownership,permissions,smart contracts,type systems},
}

@PhdThesis{Mota2020,
  author   = {Mota, Jo{\~{a}}o},
  school   = {FCT-NOVA},
  title    = {{Coping with the reality : adding crucial features to a typestate-oriented language}},
  year     = {2020},
  abstract = {Detecting programming errors and vulnerabilities in software is increasingly impor- tant, and building tools that help with this task is an area of investigation, crucial for the industry these days. When programming in an object-oriented language, one naturally defines stateful objects that are non-uniform, i.e., their methods' availability depend on their internal state. One might represent their intended usage protocol with an automaton or a state machine. Behavioral types allow to statically check if all the code of a program respects the usage protocol of each object. Mungo is a tool that extends Java with typestate definitions. These typestates are as- sociated with Java classes and define the behavior of instances of those classes, specifying the sequences of method calls allowed. The Mungo tool checks statically that method calls happen in order, following the specified behavior. Mungo misses crucial features to allow common programming practices: generics and collections are the main ones. The need for these features is illustrated by examples, like an auction that stores a collection of clients, where a usage protocol must be followed. Our goal is to define rigorously the extension to the language, develop the compiler to cope with the required functionalities, and test it with examples of realistic protocols, like Europay Mastercard Visa. Additionally, we will improve developer experience by, for instance, removing artificial restrictions that are not necessary for the verification of code, like the use of an enumeration when a boolean value is preferable. Furthermore, we will explore if the currently used frameworks, JastAdd and ExtendJ, can be replaced by a different one, for example, the Checker Framework, to increase productivity and reduce maintenance burden.},
  file     = {:home/jmgd/Documents/work/msc/biblio/ravara/thesis-JoaoMota.pdf:pdf},
  groups   = {Articles},
}

@Article{Trindade2020,
  author   = {Trindade, Andr{\'{e}} and Mota, Jo{\~{a}}o and Ravara, Antonio},
  journal  = {Electronic Proceedings in Theoretical Computer Science, EPTCS},
  title    = {{Typestates to automata and back: A tool}},
  year     = {2020},
  issn     = {20752180},
  number   = {Ice},
  pages    = {25--42},
  volume   = {324},
  abstract = {Development of software is an iterative process. Graphical tools to represent the relevant entities and processes can be helpful. In particular, automata capture well the intended execution flow of applications, and are thus behind many formal approaches, namely behavioral types. Typestate-oriented programming allow us to model and validate the intended protocol of applications, not only providing a top-down approach to the development of software, but also coping well with compositional development. Moreover, it provides important static guarantees like protocol fidelity and some forms of progress. Mungo is a front-end tool for Java that associates a typestate describing the valid orders of method calls to each class, and statically checks that the code of all classes follows the prescribed order of method calls. To assist programming with Mungo, as typestates are textual descriptions that are terms of an elaborate grammar, we developed a tool that bidirectionally converts typestates into an adequate form of automata, providing on one direction a visualization of the underlying protocol specified by the typestate, and on the reverse direction a way to get a syntactically correct typestate from the more intuitive automata representation.},
  doi      = {10.4204/EPTCS.324.4},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/2009.08769.pdf:pdf},
  groups   = {Articles},
}

@Article{Voinea2020,
  author   = {Voinea, A. Laura and Dardha, Ornela and Gay, Simon J.},
  journal  = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  title    = {{Typechecking java protocols with [st]mungo}},
  year     = {2020},
  issn     = {16113349},
  pages    = {208--224},
  volume   = {12136 LNCS},
  abstract = {This is a tutorial paper on [St]Mungo, a toolchain based on multiparty session types and their connection to typestates for safe distributed programming in Java language. The StMungo (“Scribble-to-Mungo”) tool is a bridge between multiparty session types and typestates. StMungo translates a communication protocol, namely a sequence of sends and receives of messages, given as a multiparty session type in the Scribble language, into a typestate specification and a Java API skeleton. The generated API skeleton is then further extended with the necessary logic, and finally typechecked by Mungo. The Mungo tool extends Java with (optional) typestate specifications. A typestate is a state machine specifying a Java object protocol, namely the permitted sequence of method calls of that object. Mungo statically typechecks that method calls follow the object's protocol, as defined by its typestate specification. Finally, if no errors are reported, the code is compiled with javac and run as standard Java code. In this tutorial paper we give an overview of the stages of the [St]Mungo toolchain, starting from Scribble communication protocols, translating to Java classes with typestates, and finally to typechecking method calls with Mungo. We illustrate the [St]Mungo toolchain via a real-world case study, the HTTP client-server request-response protocol over TCP. During the tutorial session, we will apply [St]Mungo to a range of examples having increasing complexity, with HTTP being one of them.},
  doi      = {10.1007/978-3-030-50086-3_12},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mungo/VDG20.pdf:pdf},
  groups   = {Articles},
  isbn     = {9783030500856},
  keywords = {HTTP protocol,Multiparty session types,Mungo,StMungo,Typestate},
}

@Book{Lagaillardie2020,
  author    = {Lagaillardie, Nicolas and Neykova, Rumyana and Yoshida, Nobuko},
  publisher = {Springer International Publishing},
  title     = {{Implementing multiparty session types in rust}},
  year      = {2020},
  isbn      = {9783030500283},
  volume    = {12134 LNCS},
  abstract  = {Multiparty Session Types (MPST) is a typing discipline for distributed protocols, which ensures communication safety and deadlock-freedom for more than two participants. This paper reports on our research project, implementing multiparty session types in Rust. Current Rust implementations of session types are limited to binary (two-party communications). We extend an existing library for binary session types to MPST. We have implemented a simplified Amazon Prime Video Streaming protocol using our library for both shared and distributed communication transports.},
  booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  doi       = {10.1007/978-3-030-50029-0_8},
  file      = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/Lagaillardie2020{\_}Chapter{\_}ImplementingMultipartySessionT.pdf:pdf},
  groups    = {Articles},
  issn      = {16113349},
  pages     = {127--136},
  url       = {http://dx.doi.org/10.1007/978-3-030-50029-0{\_}8},
}

@Article{Coblenz2020,
  author   = {Coblenz, Michael and Aldrich, Jonathan and Myers, Brad A. and Sunshine, Joshua},
  journal  = {Proceedings of the ACM on Programming Languages},
  title    = {{Can advanced type systems be usable? An empirical study of ownership, assets, and typestate in Obsidian}},
  year     = {2020},
  issn     = {2475-1421},
  number   = {OOPSLA},
  pages    = {1--28},
  volume   = {4},
  doi      = {10.1145/3428200},
  file     = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/3428200.pdf:pdf},
  groups   = {Articles},
  keywords = {typestate, linear types, ownership, assets, permis},
}

@Article{CheckerFramework2018,
  author          = {{Checker Framework}},
  title           = {{The Checker Framework Manual : Custom pluggable types for Java}},
  year            = {2018},
  number          = {page 15},
  pages           = {253},
  volume          = {0},
  file            = {:home/jmgd/Documents/work/msc/biblio/checker-framework-manual.pdf:pdf},
  groups          = {Articles},
  mendeley-groups = {Thesis (Typestates)/Articles},
  url             = {https://checkerframework.org/},
}

@Misc{Whitequark2014,
  author   = {Whitequark},
  title    = {{A Guide to Extension Points in OCaml}},
  year     = {2014},
  groups   = {Links},
  keywords = {ocaml},
  url      = {https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/},
  urldate  = {2021-01-14},
}

@Misc{OKane2020,
  author    = {O'Kane, Sean},
  title     = {{Boeing finds another software problem on the 737 Max}},
  year      = {2020},
  abstract  = {The plane won't fly again for a while},
  booktitle = {The Verge},
  groups    = {Links},
  url       = {https://www.theverge.com/2020/2/6/21126364/boeing-737-max-software-glitch-flaw-problem},
}

@Misc{Rauglaudre2003,
  author = {de Rauglaudre, Daniel},
  title  = {{Camlp4 - Reference Manual}},
  year   = {2003},
  groups = {Links},
  url    = {https://caml.inria.fr/pub/docs/manual-camlp4/manual007.html},
}

@Misc{Vicompany2018,
  author     = {Vicompany},
  title      = {{Coinbase disclosed on HackerOne: Ethereum account balance manipulation}},
  year       = {2018},
  abstract   = {The researchers noticed an issue with our ETH receiving code when receiving from a contract. This allowed sending of ETH to Coinbase to be credited even if the underlying contract execution failed. The issue was fixed by changing the contract handling logic. Analysis of the issue indicated only accidental loss for Coinbase, and no exploitation attempts. The Security team thanks @vicompany for...},
  booktitle  = {HackerOne},
  groups     = {Links},
  shorttitle = {Coinbase attack disclosed on HackerOne},
  url        = {https://hackerone.com/reports/300748},
}

@Misc{,
  title  = {{Dagger 2}},
  groups = {Links},
  url    = {https://dagger.dev/},
}

@Misc{Tolnay2021,
  author  = {Tolnay, David},
  title   = {{derive(Error) crate}},
  year    = {2021},
  groups  = {Links},
  url     = {https://github.com/dtolnay/thiserror},
  urldate = {2021-01-18},
}

@Misc{,
  title   = {{Docker GitHub organization}},
  groups  = {Links},
  url     = {https://github.com/docker},
  urldate = {2021-01-20},
}

@Misc{,
  title   = {{Effective Go}},
  groups  = {Links},
  url     = {https://golang.org/doc/effective{\_}go.html},
  urldate = {2021-01-22},
}

@Misc{Turon2015,
  author   = {Turon, Aaron},
  title    = {{Fearless Concurrency with Rust - Rust Blog}},
  year     = {2015},
  abstract = {Empowering everyone to build reliable and efficient software.},
  groups   = {Links},
  url      = {https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html},
}

@Misc{2021,
  title   = {{Guide to Rustc Development}},
  year    = {2021},
  groups  = {Links},
  urldate = {2021-01-18},
}

@Misc{2021a,
  month  = {jan},
  title  = {{Heartbleed Bug}},
  year   = {2021},
  groups = {Links},
  url    = {https://heartbleed.com/},
}

@Misc{Koxiaet2020,
  author  = {Koxiaet},
  title   = {{How to Write Hygienic Rust Macros}},
  year    = {2020},
  groups  = {Links},
  url     = {https://gist.github.com/Koxiaet/8c05ebd4e0e9347eb05f265dfb7252e1},
  urldate = {2021-01-18},
}

@Misc{Foundation,
  author  = {Foundation, The Linux},
  title   = {{Hyperledger Fabric}},
  groups  = {Links},
  urldate = {2021-01-15},
}

@Misc{,
  title   = {{inline-python - Inline Python code directly in your Rust code}},
  groups  = {Links},
  url     = {https://github.com/fusion-engineering/inline-python},
  urldate = {2021-01-19},
}

@Misc{Darcy,
  author = {Darcy, Joe},
  title  = {{JSR 269: Pluggable Annotation Processing API}},
  groups = {Links},
  url    = {https://jcp.org/en/jsr/detail?id=269},
}

@Misc{,
  title   = {{Kubernetes GitHub organization}},
  groups  = {Links},
  url     = {https://github.com/kubernetes},
  urldate = {2020-01-20},
}

@Misc{Wong,
  author  = {Wong, Chris},
  title   = {{maud - Compile-time HTML templates for Rust}},
  groups  = {Links},
  url     = {https://github.com/lambda-fairy/maud},
  urldate = {2021-01-19},
}

@Misc{,
  title    = {{Memory safety - The Chromium Projects}},
  abstract = {Home of the Chromium Open Source Project},
  groups   = {Links},
  url      = {https://www.chromium.org/Home/chromium-security/memory-safety},
}

@Misc{Mageit2020,
  author    = {Mageit, Sara},
  title     = {{NHS COVID-19 contact tracing app fails to ask users to self-isolate}},
  year      = {2020},
  abstract  = {The software glitch is the latest in a long line of tech issues to have affected the UK contact tracing app.},
  booktitle = {Healthcare IT News},
  groups    = {Links},
  url       = {https://www.healthcareitnews.com/news/emea/nhs-covid-19-contact-tracing-app-fails-ask-users-self-isolate},
}

@Misc{Hoare2009,
  author  = {Hoare, Tony},
  title   = {{Null References: The Billion Dollar Mistake}},
  year    = {2009},
  groups  = {Links},
  url     = {https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/},
  urldate = {2020-01-25},
}

@Misc{Torre2014,
  author = {Torre, Charles and Stroustrup, Bjarne and Alexandrescu, Andrei and Pike, Rob and Matsakis, Niko},
  title  = {{Panel: Systems Programming in 2014 and Beyond}},
  year   = {2014},
  groups = {Links},
  url    = {https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond},
}

@Misc{2021b,
  month  = {jan},
  title  = {{PureScript}},
  year   = {2021},
  groups = {Links},
  url    = {https://www.purescript.org/},
}

@Misc{,
  title    = {{Reason {\textperiodcentered} Reason lets you write simple, fast and quality type safe code while leveraging both the JavaScript {\&} OCaml ecosystems.}},
  abstract = {Reason lets you write simple, fast and quality type safe code while leveraging both the JavaScript {\&} OCaml ecosystems.},
  groups   = {Links},
  url      = {https://reasonml.github.io/},
}

@Misc{2021c,
  title   = {{Rocket Web Framework}},
  year    = {2021},
  groups  = {Links},
  url     = {https://rocket.rs/},
  urldate = {2021-01-19},
}

@Misc{2021d,
  month     = {jan},
  title     = {ruby/rbs},
  year      = {2021},
  abstract  = {Type Signature for Ruby. Contribute to ruby/rbs development by creating an account on GitHub.},
  groups    = {Links},
  keywords  = {ruby,type-checking},
  language  = {Ruby},
  publisher = {The Ruby Programming Language},
  url       = {https://github.com/ruby/rbs},
}

@Misc{Hoare2010,
  author = {Hoare, Graydon},
  title  = {rust-lang/rust - first commit},
  year   = {2010},
  groups = {Links},
  url    = {https://github.com/rust-lang/rust/commit/c01efc669f09508b55eced32d3c88702578a7c3e},
}

@Misc{Duarte2020,
  author    = {Duarte, Jos{\'{e}}},
  title     = {{Rusty Typestates}},
  year      = {2020},
  booktitle = {rustype/notes},
  groups    = {Links},
  url       = {https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index.html},
}

@Misc{Munksgard,
  author   = {Munksgard, Philip},
  title    = {session-types},
  abstract = {Using this library, you can implement bi-directional process communication with compile-time assurance that neither party will violate the communication protocol.},
  groups   = {Links},
  url      = {https://github.com/Munksgaard/session-types},
  urldate  = {2021-01-20},
}

@Misc{,
  title   = {{SIGAda}},
  groups  = {Links},
  url     = {https://www.sigada.org/},
  urldate = {2021-01-20},
}

@Misc{OKane2019,
  author    = {O'Kane, Sean},
  title     = {{Southwest and United Airlines extend 737 Max cancellations after new flaw found}},
  year      = {2019},
  abstract  = {US airlines are split on what the FAA's discovery means for the plane},
  booktitle = {The Verge},
  groups    = {Links},
  url       = {https://www.theverge.com/2019/6/27/18761434/737-max-new-flaw-cancellation-extended-southwest-united-airlines-faa},
}

@Misc{Fitzgerald2019,
  author = {Fitzgerald, Nick},
  title  = {{state{\_}machine{\_}future - Easily create type-safe `Future`s from state machines — without the boilerplate.}},
  year   = {2019},
  groups = {Links},
  url    = {https://github.com/fitzgen/state{\_}machine{\_}future},
}

@Misc{2021e,
  title    = {stm32-rs},
  year     = {2021},
  abstract = {Community Rust support projects for STM32 microcontrollers},
  groups   = {Links},
  url      = {https://github.com/stm32-rs/},
}

@Misc{,
  title   = {{The Ada Programming Language}},
  groups  = {Links},
  url     = {https://web.archive.org/web/20160522063844/http://groups.engin.umd.umich.edu/CIS/course.des/cis400/ada/ada.html},
  urldate = {2021-01-20},
}

@Misc{2021f,
  title         = {{The Embedded Rust Book}},
  year          = {2021},
  groups        = {Links},
  keywords      = {rust},
  mendeley-tags = {rust},
  url           = {https://rust-embedded.github.io/book/},
}

@Misc{Wirth2021,
  author = {Wirth, Lukas},
  title  = {{The Little Book of Rust Macros}},
  year   = {2021},
  groups = {Links},
  url    = {https://veykril.github.io/tlborm},
}

@Misc{Campbell2019,
  author    = {Campbell, Darryl},
  title     = {{The many human errors that brought down the Boeing 737 Max}},
  year      = {2019},
  abstract  = {A damning investigation revealing the many small failures that led to 346 lives being lost.},
  booktitle = {The Verge},
  groups    = {Links},
  url       = {https://www.theverge.com/2019/5/2/18518176/boeing-737-max-crash-problems-human-error-mcas-faa},
}

@Misc{2021g,
  title   = {{The Rust Programming Language}},
  year    = {2021},
  groups  = {Links},
  url     = {https://doc.rust-lang.org/book/},
  urldate = {2021-01-18},
}

@Misc{2021h,
  title   = {{The Rust Reference}},
  year    = {2021},
  groups  = {Links},
  url     = {https://doc.rust-lang.org/reference},
  urldate = {2021-01-18},
}

@Misc{2021i,
  title   = {{The Rust RFC Book}},
  year    = {2021},
  groups  = {Links},
  url     = {https://rust-lang.github.io/rfcs/},
  urldate = {2021-01-18},
}

@Misc{Palmer,
  author  = {Palmer, Tom},
  title   = {tjpalmer/languish},
  groups  = {Links},
  url     = {https://tjpalmer.github.io/languish/},
  urldate = {2021-01-25},
}

@Misc{MillerMatt2019,
  author    = {{Miller, Matt}, (MSRC)},
  title     = {{Trends, challenges and strategic shifts in the software vulnerability mitigation landscape}},
  year      = {2019},
  abstract  = {Security Research from the Microsoft Security Response Center (MSRC) - microsoft/MSRC-Security-Research},
  booktitle = {GitHub},
  groups    = {Links},
  url       = {https://git.io/JLdDc},
}

@Misc{,
  title    = {{Typed JavaScript at Any Scale.}},
  abstract = {TypeScript extends JavaScript by adding types to the language. TypeScript speeds up your development experience by catching errors and providing fixes before you even run your code.},
  groups   = {Links},
  url      = {https://www.typescriptlang.org/},
}

@Misc{Stokke,
  author  = {Stokke, Bodil},
  title   = {{typed-html - Type checked JSX for Rust}},
  groups  = {Links},
  url     = {https://github.com/bodil/typed-html},
  urldate = {2021-01-19},
}

@Misc{,
  title   = {{typing — Support for type hints — Python 3.9.1 documentation}},
  groups  = {Links},
  url     = {https://docs.python.org/3/library/typing.html},
  urldate = {2021-01-14},
}

@Misc{Feldman2014,
  author  = {Feldman, Michael B.},
  title   = {{Who's Using Ada}},
  year    = {2014},
  groups  = {Links},
  url     = {https://www2.seas.gwu.edu/{~}mfeldman/ada-project-summary.html},
  urldate = {2021-01-20},
}

@Misc{Heaney1998,
  author  = {Heaney, Mathew},
  title   = {{Why Ada isn't Popular}},
  year    = {1998},
  groups  = {Links},
  url     = {http://www.adapower.com/index.php?Command=Class{\&}ClassID=Advocacy{\&}CID=39},
  urldate = {2020-01-25},
}

@Misc{Howarth2020,
  author  = {Howarth, Jesse},
  title   = {{Why Discord is switching from Go to Rust}},
  year    = {2020},
  groups  = {Links},
  url     = {https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f},
  urldate = {2021-01-20},
}

@Misc{Leroy2020,
  author  = {Leroy, Xavier and Doligez, Damien and Frisch, Alain and Garrigue, Jacques and R{\'{e}}my, Didier and Vouillon, J{\'{e}}r{\^{o}}me},
  title   = {{The OCaml system release 4.11 - Documentation and user's manual}},
  year    = {2020},
  groups  = {Links},
  url     = {https://caml.inria.fr/pub/docs/manual-ocaml/},
  urldate = {2/2/2021},
}

@Misc{Rebours2019,
  author  = {Rebours, Nathan},
  title   = {{An introduction to OCaml PPX ecosystem}},
  year    = {2019},
  groups  = {Links},
  url     = {https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem},
  urldate = {4/2/2021},
}

@Article{Ekman2007,
  author    = {Torbjörn Ekman and Görel Hedin},
  title     = {The JastAdd Extensible Java Compiler},
  year      = {2007},
  month     = {oct},
  number    = {10},
  pages     = {1--18},
  volume    = {42},
  doi       = {10.1145/1297105.1297029},
  file      = {:/home/jmgd/Documents/work/msc/biblio/compiler/1297105.1297029.pdf:PDF},
  groups    = {Articles},
  keywords  = {OOP, Compilers, Extensibility, Declarative Fra- tests in the Jacks test suite [jac07a] than popular compilers meworks, Modularity, Java like javac and the Eclipse compiler},
  publisher = {Association for Computing Machinery ({ACM})},
}

@Misc{Square2021,
  author   = {Square},
  title    = {square/javapoet},
  abstract = {A Java API for generating .java source files.},
  groups   = {Links},
  url      = {https://github.com/square/javapoet},
  urldate  = {4/2/2021},
}

@Misc{JastAdd2021,
  title   = {JastAdd},
  groups  = {Links},
  url     = {https://jastadd.cs.lth.se/web/},
  urldate = {4/2/2021},
}

@Comment{jabref-meta: databaseType:bibtex;}

@Comment{jabref-meta: grouping:
0 AllEntriesGroup:;
1 StaticGroup:Articles\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Links\;0\;1\;0x8a8a8aff\;\;\;;
}
