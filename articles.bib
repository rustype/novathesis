@article{Huttel2016,
abstract = {Behavioural type systems, usually associated to concurrent or distributed computations, encompass concepts such as interfaces, communication protocols, and contracts, in addition to the traditional input/output operations. The behavioural type of a software component specifies its expected patterns of interaction using expressive type languages, so types can be used to determine automatically whether the component interacts correctly with other components. Two related important notions of behavioural types are those of session types and behavioural contracts. This article surveys the main accomplishments of the last 20 years within these two approaches.},
author = {H{\"{u}}ttel, Hans and Lanese, Ivan and Vasconcelos, Vasco T. and Caires, L{\'{u}}is and Carbone, Mmarco and Deni{\'{e}}lou, Pierre Malo and Mostrous, Dimitris and Padovani, Luca and Ni{\'{o}}ravara, Ant{\'{o}} and Tuosto, Emilio and Vieira, Hugo Torres and Zavattaro, Gianluigi},
doi = {10.1145/2873052},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/2873052.pdf:pdf},
issn = {15577341},
journal = {ACM Computing Surveys},
keywords = {Behavioural types},
number = {1},
pages = {1--36},
title = {{Foundations of session types and behavioural contracts}},
volume = {49},
year = {2016}
}
@book{Gay2017,
abstract = {Behavioural type systems in programming languages support the specification and verification of properties of programs beyond the traditional use of type systems to describe data processing. A major example of such a property is correctness of communication in concurrent and distributed systems, motivated by the importance of structured communication in modern software. Behavioural Types: from Theory to Tools presents programming languages and software tools produced by members of COST Action IC1201: Behavioural Types for Reliable Large-Scale Software Systems, a European research network that was funded from October 2012 to October 2016. As a survey of the most recent developments in the application of behavioural type systems, it is a valuable reference for researchers in the field, as well as an introduction to the area for graduate students and software developers.},
author = {Gay, Simon and Ravara, Ant{\'{o}}nio},
booktitle = {Behavioural Types: from Theory to Tools English},
doi = {10.13052/rp-9788793519817},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/RE_9788793519817.pdf:pdf},
isbn = {9788793519817},
pages = {1--375},
title = {{Behavioural types: From theory to tools english}},
year = {2017}
}
@book{Lagaillardie2020,
abstract = {Multiparty Session Types (MPST) is a typing discipline for distributed protocols, which ensures communication safety and deadlock-freedom for more than two participants. This paper reports on our research project, implementing multiparty session types in Rust. Current Rust implementations of session types are limited to binary (two-party communications). We extend an existing library for binary session types to MPST. We have implemented a simplified Amazon Prime Video Streaming protocol using our library for both shared and distributed communication transports.},
author = {Lagaillardie, Nicolas and Neykova, Rumyana and Yoshida, Nobuko},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-030-50029-0_8},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/Lagaillardie2020_Chapter_ImplementingMultipartySessionT.pdf:pdf},
isbn = {9783030500283},
issn = {16113349},
pages = {127--136},
publisher = {Springer International Publishing},
title = {{Implementing multiparty session types in rust}},
url = {http://dx.doi.org/10.1007/978-3-030-50029-0_8},
volume = {12134 LNCS},
year = {2020}
}
@article{Vasconcelos2017,
abstract = {The widespread use of service-oriented and cloud computing is creating a need for a communication-based programming approach to distributed concurrent software systems. Protocols play a central role in the design and development of such systems but mainstream programming languages still give poor support to ensure protocol compatibility. Testing alone is insufficient to ensure it, so there is a pressing need for tools to assist the development of these kind of systems. While there are tools to verify statically objectoriented code equipped with assertions, these mainly help to prevent runtime errors. However, a program can be illbehaved and still execute without terminating abruptly. It is important to guarantee that the code implements correctly its communication protocol. Our contribution is a tool to analyse source code written in a subset of Java, equipped with assertions, and return it annotated with its respective behavioural types that can be used to verify statically that the code implements the intended protocol of the application. A running example illustrates each step of the tool.},
author = {Vasconcelos, Cl{\'{a}}udio and Ravara, Ant{\'{o}}nio},
doi = {10.1145/3019612.3019733},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mool/3019612.3019733.pdf:pdf},
isbn = {9781450344869},
journal = {Proceedings of the ACM Symposium on Applied Computing},
keywords = {Assertions,Behavioural types,Object-oriented programming},
pages = {1492--1497},
title = {{From object-oriented code with assertions to behavioural types}},
volume = {Part F1280},
year = {2017}
}
@article{Vasconcelos2006,
abstract = {We define a language whose type system, incorporating session types, allows complex protocols to be specified by types and verified by static type checking. A session type, associated with a communication channel, specifies the state transitions of a protocol and also the data types of messages associated with transitions; thus type checking can verify both correctness of individual messages and correctness of sequences of transitions. Previously, session types have mainly been studied in the context of the $\pi$-calculus; instead, our formulation is based on a multithreaded functional language with side-effecting input/output operations. Our typing judgements statically describe dynamic changes in the types of channels, and our function types not only specify argument and result types but also describe changes in channels. We formalize the syntax, semantics and type checking system of our language, and prove subject reduction and runtime type safety theorems. {\textcopyright} 2006 Elsevier B.V. All rights reserved.},
author = {Vasconcelos, Vasco T. and Gay, Simon J. and Ravara, Ant{\'{o}}nio},
doi = {10.1016/j.tcs.2006.06.028},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/10.1016_j.tcs.2006.06.028.pdf:pdf},
issn = {03043975},
journal = {Theoretical Computer Science},
keywords = {Concurrent programming,Session types,Specification of communication protocols,Static type checking},
number = {1-2},
pages = {64--87},
title = {{Type checking a multithreaded functional language with session types}},
volume = {368},
year = {2006}
}
@article{Vasconcelos2016,
abstract = {We present here in a thorough analysis of the Mool language, covering not only its implementation but also the formalisation (syntax, operational semantics, and type system). The objective is to detect glitches in both the implementation and in the formal definitions, proposing as well new features and added expressiveness. To test our proposals we implemented the revision developed in the Racket platform.},
archivePrefix = {arXiv},
arxivId = {1604.06245},
author = {Vasconcelos, Cl{\'{a}}udio and Ravara, Ant{\'{o}}nio},
eprint = {1604.06245},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mool/1604.06245.pdf:pdf},
pages = {1--34},
title = {{A Revision of the Mool Language}},
url = {http://arxiv.org/abs/1604.06245},
year = {2016}
}
@article{Cardelli2004,
abstract = {The fundamental purpose of a type system is to prevent the occurrence of execution errors during the running of a program. This informal statement motivates the study of type systems, but requires clarification. Its accuracy depends, first of all, on the rather subtle issue of what constitutes an execution error, which we will discuss in detail. Even when that is settled, the absence of execution errors is a nontrivial property. When such a property holds for all the program runs that can be expressed within a programming language, we say that the language is type sound. It turns out that a fair amount of careful analysis is required to avoid false and embarrassing claims of type soundness for programming languages. As a consequence, the classification, description, and study of type systems has emerged as a formal discipline.},
author = {Cardelli, Luca},
doi = {10.1201/9781420043839.ch9},
file = {:home/jmgd/Documents/work/msc/biblio/type-systems/TypeSystems.pdf:pdf},
isbn = {9780203494455},
issn = {0360-0300},
journal = {Computer Science Handbook, Second Edition},
pages = {97--1--97--32},
title = {{Type systems}},
year = {2004}
}
@article{Stork2009,
abstract = {The rise of the multicore era is catapulting concurrency into mainstream programming. Current programming paradigms build in sequentiality, and as a result, concurrency support in those languages forces programmers into low-level reasoning about execution order. In this paper, we introduce a new programming paradigm in which concurrency is the default. Our Aeminium language uses access permissions to express logical dependencies in the code at a higher level of abstraction than sequential order. Therefore compiler/runtime-system can leverage that dependency information to allow concurrent execution. Because in Aeminium programmers specify dependencies rather than control flow, there is no need to engage in difficult, error-prone, and low-level reasoning about execution order or thread interleavings. Developers can instead focus on the design of the program, and benefit as the runtime automatically extracts the concurrency inherent in their design. Copyright {\textcopyright} 2009 ACM.},
author = {Stork, Sven and Marques, Paulo and Aldrich, Jonathan},
doi = {10.1145/1639950.1640060},
file = {:home/jmgd/Documents/work/msc/biblio/onward2009-concurrency.pdf:pdf},
isbn = {9781605587660},
journal = {Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, OOPSLA},
keywords = {Access permissions,Concurrency,Dataflow,Programming language},
pages = {933--940},
title = {{Concurrency by default: Using permissions to express dataflow in stateful programs}},
year = {2009}
}
@article{Trindade2020,
abstract = {Development of software is an iterative process. Graphical tools to represent the relevant entities and processes can be helpful. In particular, automata capture well the intended execution flow of applications, and are thus behind many formal approaches, namely behavioral types. Typestate-oriented programming allow us to model and validate the intended protocol of applications, not only providing a top-down approach to the development of software, but also coping well with compositional development. Moreover, it provides important static guarantees like protocol fidelity and some forms of progress. Mungo is a front-end tool for Java that associates a typestate describing the valid orders of method calls to each class, and statically checks that the code of all classes follows the prescribed order of method calls. To assist programming with Mungo, as typestates are textual descriptions that are terms of an elaborate grammar, we developed a tool that bidirectionally converts typestates into an adequate form of automata, providing on one direction a visualization of the underlying protocol specified by the typestate, and on the reverse direction a way to get a syntactically correct typestate from the more intuitive automata representation.},
author = {Trindade, Andr{\'{e}} and Mota, Jo{\~{a}}o and Ravara, Antonio},
doi = {10.4204/EPTCS.324.4},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/2009.08769.pdf:pdf},
issn = {20752180},
journal = {Electronic Proceedings in Theoretical Computer Science, EPTCS},
number = {Ice},
pages = {25--42},
title = {{Typestates to automata and back: A tool}},
volume = {324},
year = {2020}
}
@article{Ancona2016,
abstract = {A recent trend in programming language research is to use behavioral type theory to ensure various correctness properties of large-scale, communication-intensive systems. Behavioral types encompass concepts such as interfaces, communication protocols, contracts, and choreography. The successful application of behavioral types requires a solid understanding of several practical aspects, from their representation in a concrete programming language, to their integration with other programming constructs such as methods and functions, to design and monitoring methodologies that take behaviors into account. This survey provides an overview of the state of the art of these aspects, which we summarize as the pragmatics of behavioral types.},
author = {Ancona, Davide and Bono, Viviana and Bravetti, Mario and Campos, Joana and Castagna, Giuseppe and Deni{\'{e}}lou, Pierre Malo and Gay, Simon J. and Gesbert, Nils and Giachino, Elena and Hu, Raymond and Johnsen, Einar Broch and Martins, Francisco and Mascardi, Viviana and Montesi, Fabrizio and Neykova, Rumyana and Ng, Nicholas and Padovani, Luca and Vasconcelos, Vasco T. and Yoshida, Nobuko},
doi = {10.1561/2500000031},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/ancona2016.pdf:pdf},
issn = {23251131},
journal = {Foundations and Trends in Programming Languages},
number = {2-3},
pages = {95--230},
title = {{Behavioral types in programming languages}},
volume = {3},
year = {2016}
}
@article{Padovani2011,
abstract = {We propose a semantically grounded theory of session types which relies on intersection and union types. We argue that intersection and union types are natural candidates for modeling branching points in session types and we show that the resulting theory overcomes some important defects of related behavioral theories. In particular, intersections and unions provide a native solution to the problem of computing joins and meets of session types. Also, the subtyping relation turns out to be a pre-congruence, while this is not always the case in related behavioral theories.},
author = {Padovani, Luca},
doi = {10.4204/eptcs.45.6},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/1101.4429.pdf:pdf},
issn = {2075-2180},
journal = {Electronic Proceedings in Theoretical Computer Science},
number = {Itrs 2010},
pages = {71--89},
title = {{Session Types = Intersection Types + Union Types}},
volume = {45},
year = {2011}
}
@article{Kouzapas2018,
abstract = {Static typechecking is an important feature of many standard programming languages. However, static typing focuses on data rather than communication, and therefore does not help programmers correctly implement communication protocols in distributed systems. The theory of session types provides a basis for tackling this problem; we use it to develop two tools that support static typechecking of communication protocols in Java. The first tool, Mungo, extends Java with typestate definitions, which allow classes to be associated with state machines defining permitted sequences of method calls: for example, communication methods. The second tool, StMungo, takes a session type describing a communication protocol, and generates a typestate specification of the permitted sequences of messages in the protocol. Protocol implementations can be validated by Mungo against their typestate definitions and then compiled with a standard Java compiler. The result is a toolchain for static typechecking of communication protocols in Java. We formalise and prove soundness of the typestate inference system used by Mungo, and show that our toolchain can be used to typecheck a client for the standard Simple Mail Transfer Protocol (SMTP).},
author = {Kouzapas, Dimitrios and Dardha, Ornela and Perera, Roly and Gay, Simon J.},
doi = {10.1016/j.scico.2017.10.006},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mungo/1-s2.0-S0167642317302186-main.pdf:pdf},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Object-oriented programming,Session types,Type inference,Typestate},
pages = {52--75},
publisher = {Elsevier B.V.},
title = {{Typechecking protocols with Mungo and StMungo: A session type toolchain for Java}},
url = {https://doi.org/10.1016/j.scico.2017.10.006},
volume = {155},
year = {2018}
}
@article{Garcia2014,
author = {Garcia, Ronald and Tanter, {\'{E}}ric and Wolff, Roger and Aldrich, Jonathan},
doi = {10.1145/2629609},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/10.1145_2629609.pdf:pdf},
issn = {0164-0925},
journal = {ACM Transactions on Programming Languages and Systems},
month = {oct},
number = {4},
pages = {1--44},
title = {{Foundations of Typestate-Oriented Programming}},
url = {https://dl.acm.org/doi/10.1145/2629609},
volume = {36},
year = {2014}
}
@article{Campos2011,
abstract = {There is often a sort of a protocol associated to each class, stating when and how certain methods should be called. Given that this protocol is, if at all, described in the documentation accompanying the class, current mainstream object-oriented languages cannot provide for the verification of client code adherence against the sought class behaviour. We have defined a class-based concurrent object-oriented language that formalises such protocols in the form of usage types. Usage types are attached to class definitions, allowing for the specification of (1) the available methods, (2) the tests clients must perform on the result of methods, and (3) the object status-linear or shared-all of which depend on the object's state. Our work extends the recent approach on modular session types by eliminating channel operations, and defining the method call as the single communication primitive in both sequential and concurrent settings. In contrast to previous works, we define a single category for objects, instead of distinct categories for linear and for shared objects, and let linear objects evolve into shared ones. We introduce a standard sync qualifier to prevent thread interference in certain operations on shared objects. We formalise the language syntax, the operational semantics, and a type system that enforces by static typing that methods are called only when available, and by a single client if so specified in the usage type. We illustrate the language via a complete example.},
author = {Campos, Joana and Vasconcelos, Vasco T.},
doi = {10.4204/eptcs.69.2},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mool/1110.4157v1.pdf:pdf},
issn = {2075-2180},
journal = {Electronic Proceedings in Theoretical Computer Science},
pages = {12--28},
title = {{Channels as Objects in Concurrent Object-Oriented Programming}},
volume = {69},
year = {2011}
}
@article{Strom1986,
abstract = {We introduce a new programming language concept called typestate, which is a refinement of the concept of type. Whereas the type of a data object determines the set of operations ever permitted on the object, typestate determines the subset of these operations which is permitted in a particular context. Typestate tracking is a program analysis technique which enhances program reliability by detecting at compile-time syntactically legal but semantically undefined execution sequences. These include, for example, reading a variable before it has been initialized, dereferencing a pointer after the dynamic object has been deallocated, etc. Typestate tracking detects errors that cannot be detected by type checking or by conventional static scope rules. Additionally, typestate tracking makes it possible for compilers to insert appropriate finalization of data at exception points and on program termination, eliminating the need to support finalization by means of either garbage collection or unsafe deallocation operations such as Pascal's dispose operation. By enforcing typestate invariants at compile-time, it becomes practical to implement a “secure language''—that is, one in which all successfully compiled program modules have fully defined execution-time effects, and the only effects of program errors are incorrect output values. This paper defines typestate, gives examples of its application, and shows how typestate checking may be embedded into a compiler. We discuss the consequences of typestate checking for software reliability and software structure, and conclude with a discussion of our experience using a high-level language incorporating typestate checking. {\textcopyright} 1986 IEEE},
author = {Strom, Robert E. and Yemini, Shaula},
doi = {10.1109/TSE.1986.6312929},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/hermes/strom1986.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Program analysis,program verification,securitv,software reliability,type checking,typestate},
number = {1},
pages = {157--171},
title = {{Typestate: A Programming Language Concept for Enhancing Software Reliability}},
volume = {SE-12},
year = {1986}
}
@article{Coblenz2020,
author = {Coblenz, Michael and Aldrich, Jonathan and Myers, Brad A. and Sunshine, Joshua},
doi = {10.1145/3428200},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/3428200.pdf:pdf},
issn = {2475-1421},
journal = {Proceedings of the ACM on Programming Languages},
keywords = {typestate, linear types, ownership, assets, permis},
number = {OOPSLA},
pages = {1--28},
title = {{Can advanced type systems be usable? An empirical study of ownership, assets, and typestate in Obsidian}},
volume = {4},
year = {2020}
}
@article{Voinea2020,
abstract = {This is a tutorial paper on [St]Mungo, a toolchain based on multiparty session types and their connection to typestates for safe distributed programming in Java language. The StMungo (“Scribble-to-Mungo”) tool is a bridge between multiparty session types and typestates. StMungo translates a communication protocol, namely a sequence of sends and receives of messages, given as a multiparty session type in the Scribble language, into a typestate specification and a Java API skeleton. The generated API skeleton is then further extended with the necessary logic, and finally typechecked by Mungo. The Mungo tool extends Java with (optional) typestate specifications. A typestate is a state machine specifying a Java object protocol, namely the permitted sequence of method calls of that object. Mungo statically typechecks that method calls follow the object's protocol, as defined by its typestate specification. Finally, if no errors are reported, the code is compiled with javac and run as standard Java code. In this tutorial paper we give an overview of the stages of the [St]Mungo toolchain, starting from Scribble communication protocols, translating to Java classes with typestates, and finally to typechecking method calls with Mungo. We illustrate the [St]Mungo toolchain via a real-world case study, the HTTP client-server request-response protocol over TCP. During the tutorial session, we will apply [St]Mungo to a range of examples having increasing complexity, with HTTP being one of them.},
author = {Voinea, A. Laura and Dardha, Ornela and Gay, Simon J.},
doi = {10.1007/978-3-030-50086-3_12},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/session-types/mungo/VDG20.pdf:pdf},
isbn = {9783030500856},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {HTTP protocol,Multiparty session types,Mungo,StMungo,Typestate},
pages = {208--224},
title = {{Typechecking java protocols with [st]mungo}},
volume = {12136 LNCS},
year = {2020}
}
@inproceedings{Aldrich2009,
address = {New York, New York, USA},
author = {Aldrich, Jonathan and Sunshine, Joshua and Saini, Darpan and Sparks, Zachary},
booktitle = {Proceeding of the 24th ACM SIGPLAN conference companion on Object oriented programming systems languages and applications - OOPSLA '09},
doi = {10.1145/1639950.1640073},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/onward2009-state.pdf:pdf},
isbn = {9781605587684},
pages = {1015},
publisher = {ACM Press},
title = {{Typestate-oriented programming}},
url = {http://www.cs.cmu.edu/$\sim$aldrich/papers/onward2009-state.pdf http://dl.acm.org/citation.cfm?doid=1639950.1640073},
year = {2009}
}
@book{Strom1990,
author = {Strom, Robert E and Goldberg, Arthur P and Bacon, David F and Lowry, Andy},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/hermes/Strom90HermesTutorial.pdf:pdf},
title = {{Hermes : A Tutorial and Reference Manual}},
url = {https://researcher.watson.ibm.com/researcher/files/us-bacon/Strom90HermesTutorial.pdf},
year = {1990}
}
@inproceedings{Strom1983,
address = {New York, New York, USA},
author = {Strom, Robert E.},
booktitle = {Proceedings of the 10th ACM SIGACT-SIGPLAN symposium on Principles of programming languages - POPL '83},
doi = {10.1145/567067.567093},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/strom1983.pdf:pdf},
isbn = {0897910907},
pages = {276--284},
publisher = {ACM Press},
title = {{Mechanisms for compile-time enforcement of security}},
url = {http://portal.acm.org/citation.cfm?doid=567067.567093},
year = {1983}
}
@article{Deline2004,
abstract = {Today's mainstream object-oriented compilers and tools do not support declaring and statically checking simple pre- and postconditions on methods and invariants on object representations. The main technical problem preventing static verification is reasoning about the sharing relationships among objects as well as where object invariants should hold. We have developed a programming model of typestates for objects with a sound modular checking algorithm. The programming model handles typical aspects of object-oriented programs such as downcasting, virtual dispatch, direct calls, and subclassing. The model also permits subclasses to extend the interpretation of typestates and to introduce additional typestates. We handle aliasing by adapting our previous work on practical linear types developed in the context of the Vault system. We have implemented these ideas in a tool called Fugue for specifying and checking typestates on Microsoft .NET-based programs. {\textcopyright} Springer-Verlag 2004.},
author = {Deline, Robert and F{\"{a}}hndrich, Manuel},
doi = {10.1007/978-3-540-24851-4_21},
file = {:home/jmgd/Documents/work/msc/biblio/behavioral/typestate/deline-typestates.pdf:pdf},
isbn = {354022159X},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {465--490},
title = {{Typestates for Objects}},
volume = {3086},
year = {2004}
}
@incollection{Toninho2013,
author = {Toninho, Bernardo and Caires, Luis and Pfenning, Frank},
doi = {10.1007/978-3-642-37036-6_20},
file = {:home/jmgd/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Toninho, Caires, Pfenning - 2013 - Higher-Order Processes, Functions, and Sessions A Monadic Integration.pdf:pdf},
pages = {350--369},
title = {{Higher-Order Processes, Functions, and Sessions: A Monadic Integration}},
url = {http://link.springer.com/10.1007/978-3-642-37036-6_20},
year = {2013}
}
